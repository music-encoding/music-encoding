<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="../validation/mei_odds.rng" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<?xml-model href="../validation/mei_odds.rng" type="application/xml" schematypens="http://relaxng.org/ns/structure/1.0"?>
<specGrp xmlns="http://www.tei-c.org/ns/1.0" xmlns:tei="http://www.tei-c.org/ns/1.0"
  xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:rng="http://relaxng.org/ns/structure/1.0"
  xmlns:sch="http://purl.oclc.org/dsdl/schematron" xml:id="module.MEI.cmn">
  <moduleSpec ident="MEI.cmn">
    <desc>Common Music Notation (CMN) repertoire component declarations.</desc>
  </moduleSpec>
  <macroSpec ident="data.DURATION.cmn" module="MEI.cmn" type="dt">
    <desc>Logical, that is, written, duration attribute values for the CMN repertoire.</desc>
    <content>
      <valList type="closed">
        <valItem ident="long">
          <desc>Quadruple whole note.</desc>
        </valItem>
        <valItem ident="breve">
          <desc>Double whole note.</desc>
        </valItem>
        <valItem ident="1">
          <desc>Whole note.</desc>
        </valItem>
        <valItem ident="2">
          <desc>Half note.</desc>
        </valItem>
        <valItem ident="4">
          <desc>Quarter note.</desc>
        </valItem>
        <valItem ident="8">
          <desc>8th note.</desc>
        </valItem>
        <valItem ident="16">
          <desc>16th note.</desc>
        </valItem>
        <valItem ident="32">
          <desc>32nd note.</desc>
        </valItem>
        <valItem ident="64">
          <desc>64th note.</desc>
        </valItem>
        <valItem ident="128">
          <desc>128th note.</desc>
        </valItem>
        <valItem ident="256">
          <desc>256th note.</desc>
        </valItem>
        <valItem ident="512">
          <desc>512th note.</desc>
        </valItem>
        <valItem ident="1024">
          <desc>1024th note.</desc>
        </valItem>
        <valItem ident="2048">
          <desc>2048th note.</desc>
        </valItem>
      </valList>
    </content>
  </macroSpec>
  <macroSpec ident="data.STAFFITEM.cmn" module="MEI.cmn" type="dt">
    <desc>Items in the CMN repertoire that may be printed near a staff.</desc>
    <content>
      <valList type="closed">
        <valItem ident="beam">
          <desc>Beams.</desc>
        </valItem>
        <!-- beamSpan is subsumed within "beam" -->
        <!--<valItem ident="beamSpan"/>-->
        <valItem ident="bend">
          <desc>Bend indications.</desc>
        </valItem>
        <valItem ident="bracketSpan">
          <desc>Brackets, e.g., for transcribed ligatures.</desc>
        </valItem>
        <valItem ident="breath">
          <desc>Breath marks.</desc>
        </valItem>
        <valItem ident="cpMark">
          <desc>Copy marks.</desc>
        </valItem>
        <valItem ident="fermata">
          <desc>Fermatas.</desc>
        </valItem>
        <valItem ident="fing">
          <desc>Fingerings.</desc>
        </valItem>
        <!-- fingGrp is subsumed within "fing" -->
        <!--<valItem ident="fingGrp"/>-->
        <valItem ident="hairpin">
          <desc>Hairpin dynamics.</desc>
        </valItem>
        <valItem ident="harpPedal">
          <desc>Harp pedals.</desc>
        </valItem>
        <valItem ident="lv">
          <desc>Laissez vibrer indications, sometimes called "open ties".</desc>
        </valItem>
        <valItem ident="mordent">
          <desc>Mordents.</desc>
        </valItem>
        <valItem ident="octave">
          <desc>Octaviation marks.</desc>
        </valItem>
        <valItem ident="pedal">
          <desc>Piano pedal marks.</desc>
        </valItem>
        <valItem ident="reh">
          <desc>Rehearsal marks.</desc>
        </valItem>
        <!-- more note-attached than staff-attached? -->
        <!--<valItem ident="slur"/>-->
        <valItem ident="tie">
          <desc>Ties.</desc>
        </valItem>
        <valItem ident="trill">
          <desc>Trills.</desc>
        </valItem>
        <valItem ident="tuplet">
          <desc>Tuplets.</desc>
        </valItem>
        <!-- tupletSpan is subsumed within "tuplet" -->
        <!--<valItem ident="tupletSpan"/>-->
        <valItem ident="turn">
          <desc>Turns.</desc>
        </valItem>
      </valList>
    </content>
  </macroSpec>
  <classSpec ident="att.arpeg.log" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes.</desc>
    <classes>
      <memberOf key="att.controlEvent"/>
      <memberOf key="att.startId"/>
    </classes>
    <attList>
      <attDef ident="order" usage="opt">
        <desc>Describes the direction in which an arpeggio is to be performed.</desc>
        <valList type="closed">
          <valItem ident="up">
            <desc>Lowest to highest pitch.</desc>
          </valItem>
          <valItem ident="down">
            <desc>Highest to lowest pitch.</desc>
          </valItem>
          <valItem ident="nonarp">
            <desc>Non-arpeggiated style (usually rendered with a preceding bracket instead of a wavy
              line).</desc>
          </valItem>
        </valList>
      </attDef>
    </attList>
  </classSpec>
  <classSpec ident="att.beam.log" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes.</desc>
    <classes>
      <memberOf key="att.event"/>
      <memberOf key="att.beamedWith"/>
    </classes>
  </classSpec>
  <classSpec ident="att.beamedWith" module="MEI.cmn" type="atts">
    <desc>Attributes indicating cross-staff beaming.</desc>
    <attList>
      <attDef ident="beam.with" usage="opt">
        <desc>In the case of cross-staff beams, the beam.with attribute is used to indicate which
          staff the beam is connected to; that is, the staff above or the staff below.</desc>
        <datatype>
          <rng:ref name="data.OTHERSTAFF"/>
        </datatype>
      </attDef>
    </attList>
  </classSpec>
  <classSpec ident="att.beaming.log" module="MEI.cmn" type="atts">
    <desc>Used by layerDef, staffDef, and scoreDef to provide default values for attributes in the
      logical domain related to beaming.</desc>
    <attList>
      <attDef ident="beam.group" usage="opt">
        <desc>Provides an example of how automated beaming (including secondary beams) is to be
          performed.</desc>
        <datatype>
          <rng:data type="string"/>
        </datatype>
      </attDef>
      <attDef ident="beam.rests" usage="opt">
        <desc>Indicates whether automatically-drawn beams should include rests shorter than a
          quarter note duration.</desc>
        <datatype>
          <rng:ref name="data.BOOLEAN"/>
        </datatype>
      </attDef>
    </attList>
    <remarks>
      <p>The <att>beam.group</att> attribute can be used to set a default beaming pattern to be used
        when no beaming is indicated at the event level. <att>beam.group</att> must contain a
        comma-separated list of time values that add up to a measure, e.g., in 4/4 time '4,4,4,4'
        indicates each quarter note worth of shorter notes would be beamed together. Parentheses can
        be used to indicate sub-groupings of secondary beams. For example, '(4.,4.,4.)' in 9/8 meter
        indicates one outer beam per measure with secondary beams broken at each dotted quarter
        duration, while a measure of 16th notes in 4/4 with <att>beam.group</att> equal to
        '(4,4),(4,4)' will result in a primary beam covering all the notes and secondary beams for
        each group of 4 notes. This beaming "directive" can be overridden by using <gi scheme="MEI"
        >beam</gi> elements. If neither <gi scheme="MEI">beam</gi> elements or the
        <att>beam.group</att> attribute is used, then no beaming is rendered. Beaming can be
        explicitly 'turned off' by setting <att>beam.group</att> to an empty string.</p>
    </remarks>
  </classSpec>
  <classSpec ident="att.beamPresent" module="MEI.cmn" type="atts">
    <desc>Attributes that indicate whether an event lies under a beam.</desc>
    <attList>
      <attDef ident="beam" usage="opt">
        <desc>Indicates that this event is "under a beam".</desc>
        <datatype maxOccurs="unbounded">
          <rng:ref name="data.BEAM"/>
        </datatype>
      </attDef>
    </attList>
  </classSpec>
  <classSpec ident="att.beamRend" module="MEI.cmn" type="atts">
    <desc>Attributes that record the visual rendition of beams.</desc>
    <attList>
      <attDef ident="form" usage="opt">
        <desc>Captures whether a beam is "feathered" and in which direction.</desc>
        <valList type="closed">
          <valItem ident="acc">
            <desc>(accelerando) indicates that the secondary beams get progressively closer together
              toward the end of the beam.</desc>
          </valItem>
          <valItem ident="mixed">
            <desc>(mixed acc and rit) for beams that are "feathered" in both directions.</desc>
          </valItem>
          <valItem ident="rit">
            <desc>(ritardando) means that the secondary beams become progressively more distant
              toward the end of the beam.</desc>
          </valItem>
          <valItem ident="norm">
            <desc>(normal) indicates that the secondary beams are equidistant along the course of
              the beam.</desc>
          </valItem>
        </valList>
      </attDef>
      <attDef ident="place" usage="opt">
        <desc>Records the placement of the beam relative to the events it affects.</desc>
        <datatype>
          <rng:ref name="data.BEAMPLACE"/>
        </datatype>
        <constraintSpec ident="check_beam_place" scheme="isoschematron">
          <constraint>
            <sch:rule
              context="mei:beam[@place eq 'mixed' and not(descendant::mei:*[local-name() eq 'note' or local-name() eq 'chord'][@staff != ./@staff] or descendant::mei:*[local-name() eq 'note' or local-name() eq 'chord'][@staff != ancestor::mei:staff/@n])]">
              <sch:assert
                test="count(descendant::mei:*[local-name() eq 'note' or local-name() eq 'chord'][@stem.dir]) = count(descendant::mei:*[local-name() eq 'note' or local-name() eq 'chord'])"
                >Stem direction must be specified for all notes and chords under the
                beam.</sch:assert>
              <sch:assert
                test="count(distinct-values(descendant::mei:*[local-name() eq 'note' or local-name() eq 'chord']/@stem.dir)) &gt; 1"
                >Opposing stem directions are required for a beam with @place="mixed".</sch:assert>
            </sch:rule>
            <sch:rule
              context="mei:beam[@place eq 'mixed' and (descendant::mei:*[local-name() eq 'note' or local-name() eq 'chord'][@staff != ./@staff] or descendant::mei:*[local-name() eq 'note' or local-name() eq 'chord'][@staff != ancestor::mei:staff/@n])                 and count(descendant::mei:*[local-name() eq 'note' or local-name() eq 'chord'][@stem.dir]) = count(descendant::mei:*[local-name() eq 'note' or local-name() eq 'chord'])]">
              <sch:assert
                test="count(distinct-values(descendant::mei:*[local-name() eq 'note' or local-name() eq 'chord']/@stem.dir)) &gt; 1"
                >Opposing stem directions are required for a beam with @place="mixed".</sch:assert>
            </sch:rule>
          </constraint>
        </constraintSpec>
      </attDef>
      <attDef ident="slash" usage="opt">
        <desc>Indicates presence of slash through the beam.</desc>
        <datatype>
          <rng:ref name="data.BOOLEAN"/>
        </datatype>
      </attDef>
      <attDef ident="slope" usage="opt">
        <desc>Records the slope of the beam.</desc>
        <datatype>
          <rng:data type="decimal"/>
        </datatype>
      </attDef>
    </attList>
  </classSpec>
  <classSpec ident="att.beamSecondary" module="MEI.cmn" type="atts">
    <desc>Attributes that capture information about secondary beaming.</desc>
    <attList>
      <attDef ident="breaksec" usage="opt">
        <desc>Presence of this attribute indicates that the secondary beam should be broken
          following this note/chord. The value of the attribute records the number of beams which
          should remain unbroken.</desc>
        <datatype>
          <rng:data type="positiveInteger"/>
        </datatype>
      </attDef>
    </attList>
  </classSpec>
  <classSpec ident="att.beamSpan.log" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes.</desc>
    <classes>
      <memberOf key="att.controlEvent"/>
      <memberOf key="att.beamedWith"/>
      <memberOf key="att.duration.additive"/>
      <memberOf key="att.startEndId"/>
      <memberOf key="att.timestamp2.logical"/>
    </classes>
  </classSpec>
  <classSpec ident="att.beatRpt.log" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes.</desc>
    <classes>
      <memberOf key="att.event"/>
    </classes>
    <attList>
      <attDef ident="beatdef" usage="opt">
        <desc>Indicates the performed duration represented by the beatRpt symbol; expressed in time
          signature denominator units.</desc>
        <datatype>
          <rng:data type="decimal">
            <rng:param name="pattern">\d+(\.\d+)?</rng:param>
          </rng:data>
        </datatype>
      </attDef>
    </attList>
  </classSpec>
  <classSpec ident="att.bend.log" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes.</desc>
    <classes>
      <memberOf key="att.controlEvent"/>
      <memberOf key="att.duration.additive"/>
      <memberOf key="att.startEndId"/>
      <memberOf key="att.timestamp2.logical"/>
    </classes>
  </classSpec>
  <classSpec ident="att.bracketSpan.log" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes.</desc>
    <classes>
      <memberOf key="att.controlEvent"/>
      <memberOf key="att.duration.additive"/>
      <memberOf key="att.startEndId"/>
      <memberOf key="att.timestamp2.logical"/>
    </classes>
  </classSpec>
  <classSpec ident="att.breath.log" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes.</desc>
    <classes>
      <memberOf key="att.alignment"/>
      <memberOf key="att.layerIdent"/>
      <memberOf key="att.partIdent"/>
      <memberOf key="att.staffIdent"/>
      <memberOf key="att.startId"/>
      <memberOf key="att.timestamp.logical"/>
    </classes>
  </classSpec>
  <classSpec ident="att.bTrem.log" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes.</desc>
    <classes>
      <memberOf key="att.event"/>
      <memberOf key="att.augmentDots"/>
      <memberOf key="att.duration.logical"/>
      <memberOf key="att.numbered"/>
    </classes>
    <attList>
      <attDef ident="form" usage="opt">
        <desc>Indicates whether the tremolo is measured or unmeasured.</desc>
        <valList type="closed">
          <valItem ident="meas">
            <desc>Measured tremolo.</desc>
          </valItem>
          <valItem ident="unmeas">
            <desc>Unmeasured tremolo.</desc>
          </valItem>
        </valList>
      </attDef>
    </attList>
  </classSpec>
  <classSpec ident="att.chord.anl.cmn" module="MEI.cmn" type="atts">
    <desc>Analytical domain attributes in the CMN repertoire.</desc>
    <classes>
      <memberOf key="att.beamPresent"/>
      <memberOf key="att.fermataPresent"/>
      <memberOf key="att.lvPresent"/>
      <memberOf key="att.ornamPresent"/>
      <memberOf key="att.slurPresent"/>
      <memberOf key="att.tiePresent"/>
      <memberOf key="att.tupletPresent"/>
    </classes>
  </classSpec>
  <classSpec ident="att.chord.ges.cmn" module="MEI.cmn" type="atts">
    <desc>Gestural domain attributes for CMN features.</desc>
  </classSpec>
  <classSpec ident="att.chord.log.cmn" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes in the CMN repertoire.</desc>
    <classes>
      <memberOf key="att.graced"/>
    </classes>
  </classSpec>
  <classSpec ident="att.chord.vis.cmn" module="MEI.cmn" type="atts">
    <desc>Visual domain attributes for chord. The slur, slur.dir, slur.rend, tie, tie.dir, and
      tie.rend attributes here are "syntactic sugar" for these attributes on each of the chord's
      individual notes. The values here apply to all the notes in the chord. If some notes are
      slurred or tied while others aren't, then the individual note attributes must be used.</desc>
    <classes>
      <memberOf key="att.beamSecondary"/>
    </classes>
  </classSpec>
  <classSpec ident="att.cutout" module="MEI.cmn" type="atts">
    <desc>Attributes that indicate how to render the staff lines of the measure containing an
      element belonging to this attribute class.</desc>
    <attList>
      <attDef ident="cutout" usage="opt">
        <desc>"Cut-out" style.</desc>
        <valList type="closed">
          <valItem ident="cutout">
            <desc>The staff lines should not be drawn.</desc>
          </valItem>
        </valList>
      </attDef>
    </attList>
  </classSpec>
  <classSpec ident="att.mNum.anl" module="MEI.cmn" type="atts">
    <desc>Analytical domain attributes.</desc>
  </classSpec>
  <classSpec ident="att.mNum.ges" module="MEI.cmn" type="atts">
    <desc>Gestural domain attributes.</desc>
  </classSpec>
  <classSpec ident="att.mNum.log" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes.</desc>
  </classSpec>
  <classSpec ident="att.mNum.vis" module="MEI.cmn" type="atts">
    <desc>Visual domain attributes.</desc>
    <classes>
      <memberOf key="att.color"/>
      <memberOf key="att.placement"/>
      <memberOf key="att.typography"/>
      <memberOf key="att.visualOffset"/>
      <memberOf key="att.xy"/>
    </classes>
  </classSpec>
  <classSpec ident="att.expandable" module="MEI.cmn" type="atts">
    <desc>Attributes that indicate whether to render a repeat symbol or the source material to which
      it refers.</desc>
    <attList>
      <attDef ident="expand" usage="opt">
        <desc>Indicates whether to render a repeat symbol or the source material to which it refers.
          A value of 'true' renders the source material, while 'false' displays the repeat
          symbol.</desc>
        <datatype>
          <rng:ref name="data.BOOLEAN"/>
        </datatype>
      </attDef>
    </attList>
  </classSpec>
  <classSpec ident="att.fermata.log" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes.</desc>
    <classes>
      <memberOf key="att.controlEvent"/>
      <memberOf key="att.startEndId"/>
    </classes>
  </classSpec>
  <classSpec ident="att.fTrem.log" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes.</desc>
    <classes>
      <memberOf key="att.event"/>
      <memberOf key="att.augmentDots"/>
      <memberOf key="att.duration.logical"/>
    </classes>
    <attList>
      <attDef ident="form" usage="opt">
        <desc>Describes the style of the tremolo.</desc>
        <valList type="closed">
          <valItem ident="meas">
            <desc>Measured tremolo.</desc>
          </valItem>
          <valItem ident="unmeas">
            <desc>Unmeasured tremolo.</desc>
          </valItem>
        </valList>
      </attDef>
    </attList>
  </classSpec>
  <classSpec ident="att.glissPresent" module="MEI.cmn" type="atts">
    <desc>Attributes that indicate whether an event participates in a glissando.</desc>
    <attList>
      <attDef ident="gliss" usage="opt">
        <desc>Indicates that this element participates in a glissando. If visual information about
          the glissando needs to be recorded, then a <gi scheme="MEI">gliss</gi> element should be
          employed instead.</desc>
        <datatype>
          <rng:ref name="data.GLISSANDO"/>
        </datatype>
      </attDef>
    </attList>
  </classSpec>
  <classSpec ident="att.gliss.log" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes.</desc>
    <classes>
      <memberOf key="att.controlEvent"/>
      <memberOf key="att.duration.additive"/>
      <memberOf key="att.startEndId"/>
      <memberOf key="att.timestamp2.logical"/>
    </classes>
  </classSpec>
  <classSpec ident="att.graced" module="MEI.cmn" type="atts">
    <desc>Attributes that mark a note or chord as a "grace", how it should "steal" time, and how
      much time should be allotted to the grace note/chord.</desc>
    <attList>
      <attDef ident="grace" usage="opt">
        <desc>Marks a note or chord as a "grace" (without a definite performed duration) and records
          from which other note/chord it should "steal" time.</desc>
        <datatype>
          <rng:ref name="data.GRACE"/>
        </datatype>
      </attDef>
      <attDef ident="grace.time" usage="opt">
        <desc>Records the amount of time to be "stolen" from a non-grace note/chord.</desc>
        <datatype>
          <rng:ref name="data.PERCENT"/>
        </datatype>
      </attDef>
    </attList>
  </classSpec>
  <classSpec ident="att.graceGrp.anl" module="MEI.cmn" type="atts">
    <desc>Analytical domain attributes.</desc>
  </classSpec>
  <classSpec ident="att.graceGrp.ges" module="MEI.cmn" type="atts">
    <desc>Gestural domain attributes.</desc>
  </classSpec>
  <classSpec ident="att.graceGrp.log" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes.</desc>
    <classes>
      <memberOf key="att.event"/>
      <memberOf key="att.graced"/>
    </classes>
    <attList>
      <attDef ident="attach" usage="opt">
        <desc>Records whether the grace note group is attached to the following event or to the
          preceding one. The usual name for the latter is "Nachschlag".</desc>
        <valList type="closed">
          <valItem ident="pre">
            <desc>Attached to the preceding event.</desc>
          </valItem>
          <valItem ident="post">
            <desc>Attached to the following event.</desc>
          </valItem>
          <valItem ident="unknown">
            <desc>Attachment is ambiguous.</desc>
          </valItem>
        </valList>
      </attDef>
    </attList>
  </classSpec>
  <classSpec ident="att.graceGrp.vis" module="MEI.cmn" type="atts">
    <desc>Visual domain attributes.</desc>
    <classes>
      <memberOf key="att.color"/>
    </classes>
  </classSpec>
  <classSpec ident="att.hairpin.log" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes.</desc>
    <classes>
      <memberOf key="att.controlEvent"/>
      <memberOf key="att.duration.additive"/>
      <memberOf key="att.startEndId"/>
      <memberOf key="att.timestamp2.logical"/>
    </classes>
    <attList>
      <attDef ident="form" usage="req">
        <desc>Captures the visual rendition and function of the hairpin; that is, whether it
          indicates an increase or a decrease in volume.</desc>
        <valList type="closed">
          <valItem ident="cres">
            <desc>Crescendo; i.e., louder.</desc>
          </valItem>
          <valItem ident="dim">
            <desc>Diminuendo; i.e., softer.</desc>
          </valItem>
        </valList>
      </attDef>
      <attDef ident="niente" usage="opt">
        <desc>Indicates that the hairpin starts from or ends in silence. Often rendered as a small
          circle attached to the closed end of the hairpin. See Gould, p. 108.</desc>
        <datatype>
          <rng:ref name="data.BOOLEAN"/>
        </datatype>
      </attDef>
    </attList>
  </classSpec>
  <classSpec ident="att.halfmRpt.log" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes.</desc>
    <classes>
      <memberOf key="att.event"/>
      <memberOf key="att.duration.logical"/>
    </classes>
  </classSpec>
  <classSpec ident="att.harpPedal.log" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes. The pedal setting, i.e., flat, natural, or sharp, for each
      diatonic pitch name is indicated by the seven letter-named attributes.</desc>
    <classes>
      <memberOf key="att.controlEvent"/>
      <memberOf key="att.startEndId"/>
    </classes>
    <attList>
      <attDef ident="c" usage="opt">
        <desc>Indicates the pedal setting for the harp's C strings.</desc>
        <defaultVal>n</defaultVal>
        <valList type="closed">
          <valItem ident="f">
            <desc>Flat.</desc>
          </valItem>
          <valItem ident="n">
            <desc>Natural.</desc>
          </valItem>
          <valItem ident="s">
            <desc>Sharp.</desc>
          </valItem>
        </valList>
      </attDef>
      <attDef ident="d" usage="opt">
        <desc>Indicates the pedal setting for the harp's D strings.</desc>
        <defaultVal>n</defaultVal>
        <valList type="closed">
          <valItem ident="f">
            <desc>Flat.</desc>
          </valItem>
          <valItem ident="n">
            <desc>Natural.</desc>
          </valItem>
          <valItem ident="s">
            <desc>Sharp.</desc>
          </valItem>
        </valList>
      </attDef>
      <attDef ident="e" usage="opt">
        <desc>Indicates the pedal setting for the harp's E strings.</desc>
        <defaultVal>n</defaultVal>
        <valList type="closed">
          <valItem ident="f">
            <desc>Flat.</desc>
          </valItem>
          <valItem ident="n">
            <desc>Natural.</desc>
          </valItem>
          <valItem ident="s">
            <desc>Sharp.</desc>
          </valItem>
        </valList>
      </attDef>
      <attDef ident="f" usage="opt">
        <desc>Indicates the pedal setting for the harp's F strings.</desc>
        <defaultVal>n</defaultVal>
        <valList type="closed">
          <valItem ident="f">
            <desc>Flat.</desc>
          </valItem>
          <valItem ident="n">
            <desc>Natural.</desc>
          </valItem>
          <valItem ident="s">
            <desc>Sharp.</desc>
          </valItem>
        </valList>
      </attDef>
      <attDef ident="g" usage="opt">
        <desc>Indicates the pedal setting for the harp's G strings.</desc>
        <defaultVal>n</defaultVal>
        <valList type="closed">
          <valItem ident="f">
            <desc>Flat.</desc>
          </valItem>
          <valItem ident="n">
            <desc>Natural.</desc>
          </valItem>
          <valItem ident="s">
            <desc>Sharp.</desc>
          </valItem>
        </valList>
      </attDef>
      <attDef ident="a" usage="opt">
        <desc>Indicates the pedal setting for the harp's A strings.</desc>
        <defaultVal>n</defaultVal>
        <valList type="closed">
          <valItem ident="f">
            <desc>Flat.</desc>
          </valItem>
          <valItem ident="n">
            <desc>Natural.</desc>
          </valItem>
          <valItem ident="s">
            <desc>Sharp.</desc>
          </valItem>
        </valList>
      </attDef>
      <attDef ident="b" usage="opt">
        <desc>Indicates the pedal setting for the harp's B strings.</desc>
        <defaultVal>n</defaultVal>
        <valList type="closed">
          <valItem ident="f">
            <desc>Flat.</desc>
          </valItem>
          <valItem ident="n">
            <desc>Natural.</desc>
          </valItem>
          <valItem ident="s">
            <desc>Sharp.</desc>
          </valItem>
        </valList>
      </attDef>
    </attList>
  </classSpec>
  <classSpec ident="att.layerDef.log.cmn" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes.</desc>
    <classes>
      <memberOf key="att.beaming.log"/>
    </classes>
  </classSpec>
  <classSpec ident="att.lv.log" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes.</desc>
    <classes>
      <memberOf key="att.controlEvent"/>
      <memberOf key="att.startEndId"/>
      <memberOf key="att.timestamp2.logical"/>
    </classes>
  </classSpec>
  <classSpec ident="att.lvPresent" module="MEI.cmn" type="atts">
    <desc>Attributes that indicate the presence of an l.v. (laissez vibrer) marking attached to a
      feature. If visual information about the lv sign needs to be recorded, then an <gi
      scheme="MEI">lv</gi> element should be employed.</desc>
    <attList>
      <attDef ident="lv" usage="opt">
        <desc>Indicates the attachment of an l.v. (laissez vibrer) sign to this element.</desc>
        <datatype>
          <rng:ref name="data.BOOLEAN"/>
        </datatype>
      </attDef>
    </attList>
  </classSpec>
  <classSpec ident="att.measure.log" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes. The n attribute contains a name or number associated with the
      measure (Read, p. 445). Often, this is an integer, but not always. For example, some measures,
      especially incomplete measures or those under an ending mark, may have labels that contain an
      integer plus a suffix, such as '12a'. Measures may even have labels, especially in editorial
      or analytical uses of MEI, that are entirely non-numeric strings. Measure numbers may be
      machine-generated instead of encoding them in the markup. However, an explicit measure number
      should restart numbering with the given value. The join attribute may be used to indicate
      another measure which metrically completes the current, incomplete one.</desc>
    <classes>
      <memberOf key="att.alignment"/>
      <memberOf key="att.meterConformance.bar"/>
    </classes>
    <attList>
      <attDef ident="left" usage="opt">
        <desc>Indicates the visual rendition of the left bar line. It is present here only for
          facilitation of translation from legacy encodings which use it. Usually, it can be safely
          ignored.</desc>
        <datatype>
          <rng:ref name="data.BARRENDITION"/>
        </datatype>
      </attDef>
      <attDef ident="right" usage="opt">
        <desc>Indicates the function of the right bar line and is structurally important.</desc>
        <datatype>
          <rng:ref name="data.BARRENDITION"/>
        </datatype>
      </attDef>
    </attList>
  </classSpec>
  <classSpec ident="att.meterSigGrp.log" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes.</desc>
    <attList>
      <attDef ident="func" usage="req">
        <desc>Function of the meter signature group.</desc>
        <valList type="closed">
          <valItem ident="alternating">
            <desc>Meter signatures apply to alternating measures.</desc>
          </valItem>
          <valItem ident="interchanging">
            <desc>Meter signatures are interchangeable, e.g. 3/4 and 6/8.</desc>
          </valItem>
          <valItem ident="mixed">
            <desc>Meter signatures with different unit values are used to express a complex metrical
              pattern that is not expressible using traditional means, such as 2/4+1/8.</desc>
          </valItem>
        </valList>
      </attDef>
    </attList>
  </classSpec>
  <classSpec ident="att.mRest.log" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes.</desc>
    <classes>
      <memberOf key="att.cue"/>
      <memberOf key="att.duration.additive"/>
      <memberOf key="att.event"/>
    </classes>
  </classSpec>
  <classSpec ident="att.mRpt.log" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes.</desc>
    <classes>
      <memberOf key="att.event"/>
    </classes>
  </classSpec>
  <classSpec ident="att.mRpt2.log" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes.</desc>
    <classes>
      <memberOf key="att.event"/>
    </classes>
  </classSpec>
  <classSpec ident="att.mSpace.log" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes in the CMN repertoire.</desc>
    <classes>
      <memberOf key="att.duration.additive"/>
      <memberOf key="att.event"/>
    </classes>
  </classSpec>
  <classSpec ident="att.multiRest.log" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes.</desc>
    <classes>
      <memberOf key="att.event"/>
      <memberOf key="att.numbered"/>
    </classes>
  </classSpec>
  <classSpec ident="att.multiRpt.log" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes.</desc>
    <classes>
      <memberOf key="att.event"/>
      <memberOf key="att.numbered"/>
    </classes>
  </classSpec>
  <classSpec ident="att.note.anl.cmn" module="MEI.cmn" type="atts">
    <desc>Analytical domain attributes in the CMN repertoire.</desc>
    <classes>
      <memberOf key="att.beamPresent"/>
      <memberOf key="att.fermataPresent"/>
      <memberOf key="att.glissPresent"/>
      <memberOf key="att.lvPresent"/>
      <memberOf key="att.ornamPresent"/>
      <memberOf key="att.slurPresent"/>
      <memberOf key="att.sylText"/>
      <memberOf key="att.tiePresent"/>
      <memberOf key="att.tupletPresent"/>
    </classes>
  </classSpec>
  <classSpec ident="att.note.log.cmn" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes.</desc>
    <classes>
      <memberOf key="att.graced"/>
    </classes>
  </classSpec>
  <classSpec ident="att.note.vis.cmn" module="MEI.cmn" type="atts">
    <desc>Visual domain attributes.</desc>
    <classes>
      <memberOf key="att.beamSecondary"/>
    </classes>
  </classSpec>
  <classSpec ident="att.numbered" module="MEI.cmn" type="atts">
    <desc>Attributes that record numbers to be displayed with a feature.</desc>
    <attList>
      <attDef ident="num" usage="opt">
        <desc>Records a number or count accompanying a notational feature.</desc>
        <datatype>
          <rng:data type="positiveInteger"/>
        </datatype>
      </attDef>
    </attList>
  </classSpec>
  <classSpec ident="att.numberPlacement" module="MEI.cmn" type="atts">
    <desc>Attributes that record the placement and visibility of numbers that accompany a bowed
      tremolo or tuplet.</desc>
    <attList>
      <attDef ident="num.place" usage="opt">
        <desc>States where the tuplet number will be placed in relation to the note heads.</desc>
        <datatype>
          <rng:ref name="data.STAFFREL.basic"/>
        </datatype>
      </attDef>
      <attDef ident="num.visible" usage="opt">
        <desc>Determines if the tuplet number is visible.</desc>
        <datatype>
          <rng:ref name="data.BOOLEAN"/>
        </datatype>
      </attDef>
    </attList>
  </classSpec>
  <classSpec ident="att.octave.log" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes.</desc>
    <classes>
      <memberOf key="att.controlEvent"/>
      <memberOf key="att.duration.additive"/>
      <memberOf key="att.octaveDisplacement"/>
      <memberOf key="att.startEndId"/>
      <memberOf key="att.timestamp2.logical"/>
    </classes>
    <attList>
      <attDef ident="coll" usage="opt">
        <desc>Indicates whether the octave displacement should be performed simultaneously with the
          written notes, i.e., "coll' ottava". Unlike other octave signs which are indicated by
          broken lines, coll' ottava typically uses an unbroken line or a series of longer broken
          lines, ending with a short vertical stroke. See Read, p. 47-48.</desc>
        <valList type="closed">
          <valItem ident="coll">
            <desc>Coll' ottava (with the octave).</desc>
          </valItem>
        </valList>
      </attDef>
    </attList>
  </classSpec>
  <classSpec ident="att.ossia.log" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes.</desc>
  </classSpec>
  <classSpec ident="att.pedal.log" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes.</desc>
    <classes>
      <memberOf key="att.controlEvent"/>
      <memberOf key="att.startEndId"/>
      <memberOf key="att.timestamp2.logical"/>
    </classes>
    <attList>
      <attDef ident="dir" usage="req">
        <desc>Records the position of the piano damper pedal.</desc>
        <valList type="closed">
          <valItem ident="down">
            <desc>Depress the pedal.</desc>
          </valItem>
          <valItem ident="up">
            <desc>Release the pedal.</desc>
          </valItem>
          <valItem ident="half">
            <desc>Half pedal.</desc>
          </valItem>
          <valItem ident="bounce">
            <desc>Release then immediately depress the pedal.</desc>
          </valItem>
        </valList>
      </attDef>
      <attDef ident="func" usage="opt">
        <desc>Indicates the function of the depressed pedal, but not necessarily the text associated
          with its use. Use the <gi>dir</gi> element for such text.</desc>
        <datatype>
          <rng:data type="NMTOKEN"/>
        </datatype>
        <valList type="semi">
          <valItem ident="sustain">
            <desc>The sustain pedal, also referred to as the "damper" pedal, allows the piano
              strings to vibrate sympathetically with the struck strings. It is the right-most and
              the most frequently used pedal on modern pianos.</desc>
          </valItem>
          <valItem ident="soft">
            <desc>The soft pedal, sometimes called the "una corda", "piano", or "half-blow" pedal,
              reduces the volume and modifies the timbre of the piano. On the modern piano, it is
              the left-most pedal.</desc>
          </valItem>
          <valItem ident="sostenuto">
            <desc>The sostenuto or tone-sustaining pedal allows notes already undamped to continue
              to ring while other notes are damped normally; that is, on their release by the
              fingers. This is usually the center pedal of the modern piano.</desc>
          </valItem>
          <valItem ident="silent">
            <desc>The silent or practice pedal mutes the volume of the piano so that one may
              practice quietly. It is sometimes a replacement for the sostenuto pedal, especially on
              an upright or vertical instrument.</desc>
          </valItem>
        </valList>
      </attDef>
    </attList>
  </classSpec>
  <classSpec ident="att.phrase.vis.cmn" module="MEI.cmn" type="atts">
    <desc>Visual domain attributes.</desc>
    <classes>
      <memberOf key="att.curvature"/>
      <memberOf key="att.curveRend"/>
    </classes>
  </classSpec>
  <classSpec ident="att.pianoPedals" module="MEI.cmn" type="atts">
    <desc>Used by scoreDef and staffDef to provide default description of piano pedal
      rendition.</desc>
    <attList>
      <attDef ident="pedal.style" usage="opt">
        <desc>Determines whether piano pedal marks should be rendered as lines or as terms.</desc>
        <valList type="closed">
          <valItem ident="line">
            <desc>Continuous line with start and end positions rendered by vertical bars and bounces
              shown by upward-pointing "blips".</desc>
          </valItem>
          <valItem ident="pedstar">
            <desc>Pedal down and half pedal rendered with "Ped.", pedal up rendered by "*", pedal
              "bounce" rendered with "* Ped.".</desc>
          </valItem>
          <valItem ident="altpedstar">
            <desc>Pedal up and down indications same as with "pedstar", but bounce is rendered with
              "Ped." only.</desc>
          </valItem>
        </valList>
      </attDef>
    </attList>
  </classSpec>
  <classSpec ident="att.reh.log" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes.</desc>
    <classes>
      <memberOf key="att.alignment"/>
      <memberOf key="att.partIdent"/>
      <memberOf key="att.staffIdent"/>
      <memberOf key="att.startId"/>
      <memberOf key="att.timestamp.logical"/>
      <memberOf key="att.timestamp.gestural"/>
    </classes>
  </classSpec>
  <classSpec ident="att.rehearsal" module="MEI.cmn" type="atts">
    <desc>Attributes used by scoreDef and staffDef to provide default information about rehearsal
      numbers/letters.</desc>
    <attList>
      <attDef ident="reh.enclose" usage="opt">
        <desc>Describes the enclosing shape for rehearsal marks.</desc>
        <valList type="closed">
          <valItem ident="box">
            <desc>Enclosed by box.</desc>
          </valItem>
          <valItem ident="circle">
            <desc>Enclosed by circle.</desc>
          </valItem>
          <valItem ident="none">
            <desc>No enclosing shape.</desc>
          </valItem>
        </valList>
      </attDef>
    </attList>
  </classSpec>
  <classSpec ident="att.rest.anl.cmn" module="MEI.cmn" type="atts">
    <desc>Analytical domain attributes in the CMN repertoire.</desc>
    <classes>
      <memberOf key="att.beamPresent"/>
      <memberOf key="att.fermataPresent"/>
      <memberOf key="att.tupletPresent"/>
    </classes>
  </classSpec>
  <classSpec ident="att.rest.log.cmn" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes in the CMN repertoire.</desc>
  </classSpec>
  <classSpec ident="att.rest.vis.cmn" module="MEI.cmn" type="atts">
    <desc>Visual domain attributes.</desc>
    <classes>
      <memberOf key="att.beamSecondary"/>
    </classes>
  </classSpec>
  <classSpec ident="att.scoreDef.log.cmn" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes.</desc>
    <classes>
      <memberOf key="att.beaming.log"/>
    </classes>
  </classSpec>
  <classSpec ident="att.scoreDef.vis.cmn" module="MEI.cmn" type="atts">
    <desc>Visual domain attributes.</desc>
    <classes>
      <memberOf key="att.beaming.vis"/>
      <memberOf key="att.pianoPedals"/>
      <memberOf key="att.rehearsal"/>
      <memberOf key="att.slurRend"/>
      <memberOf key="att.tieRend"/>
    </classes>
    <attList>
      <attDef ident="grid.show" usage="opt">
        <desc>Determines whether to display guitar chord grids.</desc>
        <datatype>
          <rng:ref name="data.BOOLEAN"/>
        </datatype>
      </attDef>
    </attList>
  </classSpec>
  <classSpec ident="att.slur.log" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes.</desc>
    <classes>
      <memberOf key="att.controlEvent"/>
      <memberOf key="att.duration.additive"/>
      <memberOf key="att.startEndId"/>
      <memberOf key="att.timestamp2.logical"/>
    </classes>
  </classSpec>
  <classSpec ident="att.slurRend" module="MEI.cmn" type="atts">
    <desc>Attributes that describe the rendition of slurs.</desc>
    <attList>
      <attDef ident="slur.lform">
        <datatype>
          <rng:ref name="data.LINEFORM"/>
        </datatype>
      </attDef>
      <attDef ident="slur.lwidth">
        <datatype>
          <rng:ref name="data.LINEWIDTH"/>
        </datatype>
      </attDef>
    </attList>
  </classSpec>
  <classSpec ident="att.space.anl.cmn" module="MEI.cmn" type="atts">
    <desc>Analytical domain attributes in the CMN repertoire.</desc>
    <classes>
      <memberOf key="att.beamPresent"/>
      <memberOf key="att.fermataPresent"/>
      <memberOf key="att.tupletPresent"/>
    </classes>
  </classSpec>
  <classSpec ident="att.space.log.cmn" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes in the CMN repertoire.</desc>
  </classSpec>
  <classSpec ident="att.staffDef.log.cmn" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes for staffDef in the CMN repertoire.</desc>
    <classes>
      <memberOf key="att.beaming.log"/>
    </classes>
  </classSpec>
  <classSpec ident="att.staffDef.vis.cmn" module="MEI.cmn" type="atts">
    <desc>Visual domain attributes for staffDef in the CMN repertoire.</desc>
    <classes>
      <memberOf key="att.beaming.vis"/>
      <memberOf key="att.pianoPedals"/>
      <memberOf key="att.rehearsal"/>
      <memberOf key="att.slurRend"/>
      <memberOf key="att.tieRend"/>
    </classes>
  </classSpec>
  <classSpec ident="att.stems.cmn" module="MEI.cmn" type="atts">
    <desc>Attributes that describe the properties of stemmed features; that is, chords and
      notes.</desc>
    <attList>
      <attDef ident="stem.with" usage="opt">
        <desc>Contains an indication of which staff a note or chord that logically belongs to the
          current staff should be visually placed on; that is, the one above or the one
          below.</desc>
        <datatype>
          <rng:ref name="data.OTHERSTAFF"/>
        </datatype>
      </attDef>
    </attList>
  </classSpec>
  <classSpec ident="att.tie.log" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes.</desc>
    <classes>
      <memberOf key="att.controlEvent"/>
      <memberOf key="att.startEndId"/>
      <memberOf key="att.timestamp2.logical"/>
    </classes>
  </classSpec>
  <classSpec ident="att.tieRend" module="MEI.cmn" type="atts">
    <desc>Attributes that describe the rendition of ties.</desc>
    <attList>
      <attDef ident="tie.lform">
        <datatype>
          <rng:ref name="data.LINEFORM"/>
        </datatype>
      </attDef>
      <attDef ident="tie.lwidth">
        <datatype>
          <rng:ref name="data.LINEWIDTH"/>
        </datatype>
      </attDef>
    </attList>
  </classSpec>
  <classSpec ident="att.tremMeasured" module="MEI.cmn" type="atts">
    <desc>Attributes that describe measured tremolandi.</desc>
    <attList>
      <attDef ident="unitdur" usage="opt">
        <desc>The performed duration of an individual note in a measured tremolo.</desc>
        <datatype>
          <rng:ref name="data.DURATION.cmn"/>
        </datatype>
      </attDef>
    </attList>
  </classSpec>
  <classSpec ident="att.tuplet.log" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes.</desc>
    <classes>
      <memberOf key="att.beamedWith"/>
      <memberOf key="att.duration.additive"/>
      <memberOf key="att.duration.ratio"/>
      <memberOf key="att.event"/>
      <memberOf key="att.startEndId"/>
    </classes>
  </classSpec>
  <classSpec ident="att.tupletSpan.log" module="MEI.cmn" type="atts">
    <desc>Logical domain attributes.</desc>
    <classes>
      <memberOf key="att.beamedWith"/>
      <memberOf key="att.controlEvent"/>
      <memberOf key="att.duration.additive"/>
      <memberOf key="att.duration.ratio"/>
      <memberOf key="att.startEndId"/>
      <memberOf key="att.timestamp2.logical"/>
    </classes>
  </classSpec>
  <classSpec ident="model.controlEventLike.cmn" module="MEI.cmn" type="model">
    <desc>Groups control events that appear in CMN.</desc>
    <classes>
      <memberOf key="model.measurePart"/>
      <memberOf key="model.rdgPart.music"/>
      <memberOf key="model.editTransPart.music"/>
    </classes>
  </classSpec>
  <classSpec ident="model.eventLike.cmn" module="MEI.cmn" type="model">
    <desc>Groups events that appear in CMN.</desc>
    <classes>
      <memberOf key="model.layerPart.cmn"/>
    </classes>
  </classSpec>
  <classSpec ident="model.eventLike.measureFilling" module="MEI.cmn" type="model">
    <desc>Groups events that completely fill a CMN measure.</desc>
    <classes>
      <memberOf key="model.layerPart.cmn"/>
    </classes>
  </classSpec>
  <classSpec ident="model.layerPart.cmn" module="MEI.cmn" type="model">
    <desc>Groups notated events that may appear at the layer level in CMN.</desc>
    <classes>
      <memberOf key="model.layerPart"/>
    </classes>
  </classSpec>
  <classSpec ident="model.measureLike" module="MEI.cmn" type="model">
    <desc>Groups CMN measure-like elements.</desc>
    <classes>
      <memberOf key="model.sectionPart.cmn"/>
    </classes>
  </classSpec>
  <classSpec ident="model.measurePart" module="MEI.cmn" type="model">
    <desc>Groups elements that may appear within a CMN measure.</desc>
  </classSpec>
  <classSpec ident="model.ossiaLike" module="MEI.cmn" type="model">
    <desc>Groups elements that function like ossia.</desc>
    <classes>
      <memberOf key="model.measurePart"/>
      <memberOf key="model.staffPart"/>
    </classes>
  </classSpec>
  <classSpec ident="model.sectionPart.cmn" module="MEI.cmn" type="model">
    <desc>Groups elements that may appear as part of a section.</desc>
    <classes>
      <memberOf key="model.sectionPart"/>
    </classes>
  </classSpec>
  <elementSpec ident="arpeg" module="MEI.cmn">
    <desc>(arpeggiation) â€“ Indicates that the notes of a chord are to be performed successively
      rather than simultaneously, usually from lowest to highest. Sometimes called a "roll".</desc>
    <classes>
      <memberOf key="att.common"/>
      <memberOf key="att.facsimile"/>
      <memberOf key="att.arpeg.log"/>
      <memberOf key="att.arpeg.vis"/>
      <memberOf key="att.arpeg.ges"/>
      <memberOf key="att.arpeg.anl"/>
      <memberOf key="model.controlEventLike.cmn"/>
    </classes>
    <content>
      <rng:empty/>
    </content>
    <remarks>
      <p>The modern arpeggiation symbol is a vertical wavy line preceding the chord. When the notes
        of the chord are to be performed from highest to lowest, an arrowhead may be added to the
        lower end of the line. Even though it is redundant, an arrowhead is sometimes added to the
        upper end of the line for the sake of consistency or when the direction of successive
        arpeggios alternates. In music for keyboard instruments, sometimes a distinction is made
        between a single arpeggio in which both hands play successively and simultaneous arpeggios
        in two hands. In the case of the former, multiple values may be required in the
        <att>staff</att> and <att>layer</att> attributes. Arpeggios that do not cross staves, but
        still involve more than one layer require multiple values for the <att>layer</att>
        attribute.</p>
    </remarks>
  </elementSpec>
  <elementSpec ident="attacca" module="MEI.cmn">
    <desc>An instruction to begin the next section or movement of a composition without
      pause.</desc>
    <classes>
      <memberOf key="att.common"/>
      <memberOf key="att.facsimile"/>
      <memberOf key="att.lang"/>
      <memberOf key="att.attacca.log"/>
      <memberOf key="att.attacca.vis"/>
      <memberOf key="att.attacca.ges"/>
      <memberOf key="att.attacca.anl"/>
      <memberOf key="model.controlEventLike.cmn"/>
      <!--<memberOf key="model.controlEventLike"/>-->
    </classes>
    <content>
      <rng:zeroOrMore>
        <rng:choice>
          <rng:text/>
          <rng:ref name="model.textPhraseLike.limited"/>
          <rng:ref name="model.graphicPrimitiveLike"/>
          <rng:ref name="model.editLike"/>
          <rng:ref name="model.transcriptionLike"/>
        </rng:choice>
      </rng:zeroOrMore>
    </content>
    <constraintSpec ident="attacca_start-type_attributes_required" scheme="isoschematron">
      <constraint>
        <sch:rule context="mei:attacca[not(ancestor::mei:syllable)]">
          <sch:assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one of the
            attributes: startid, tstamp, tstamp.ges or tstamp.real.</sch:assert>
        </sch:rule>
      </constraint>
    </constraintSpec>
    <remarks>
      <p>As a specialized directive, <gi scheme="MEI">attacca</gi> is a control element. That is, it
        can be linked via its attributes to other events. The starting point of the attacca
        directive may be indicated by either a <att>startid</att>, <att>tstamp</att>,
        <att>tstamp.ges</att>, or <att>tstamp.real</att> attribute, while the ending point may be
        recorded by either a <att>dur</att>, <att>dur.ges</att>, <att>endid</att>, or
        <att>tstamp2</att> attribute. It is a semantic error not to specify a starting point
        attribute.</p>
    </remarks>
  </elementSpec>
  <elementSpec ident="beam" module="MEI.cmn">
    <desc>A container for a series of explicitly beamed events that begins and ends entirely within
      a measure.</desc>
    <classes>
      <memberOf key="att.common"/>
      <memberOf key="att.facsimile"/>
      <memberOf key="att.beam.log"/>
      <memberOf key="att.beam.vis"/>
      <memberOf key="att.beam.ges"/>
      <memberOf key="att.beam.anl"/>
      <memberOf key="model.eventLike.cmn"/>
    </classes>
    <content>
      <rng:zeroOrMore>
        <rng:choice>
          <rng:ref name="model.eventLike"/>
          <rng:ref name="model.eventLike.cmn"/>
          <rng:ref name="model.appLike"/>
          <rng:ref name="model.editLike"/>
          <rng:ref name="model.transcriptionLike"/>
        </rng:choice>
      </rng:zeroOrMore>
    </content>
    <constraintSpec ident="When_not_copyof_beam_content" scheme="isoschematron">
      <constraint>
        <sch:rule context="mei:beam[not(@copyof)]">
          <sch:assert
            test="count(descendant::*[local-name()='note' or local-name()='rest' or               local-name()='chord' or local-name()='space']) &gt; 1"
            >A beam without a copyof attribute must have at least 2 note, rest, chord, or space
            descendants.</sch:assert>
        </sch:rule>
      </constraint>
    </constraintSpec>
    <remarks>
      <p>For beams that cross the bar line, use the <gi scheme="MEI">beamSpan</gi> element.
        Secondary beams may be broken explicitly using the <att>breaksec</att> attribute on the
        notes or chords under the beam. Automated beaming, as opposed to explicitly marked beams,
        may be indicated for an entire score, part or section by using the <att>beam.group</att> and
        <att>beam.rests</att> attributes on these elements.</p>
    </remarks>
  </elementSpec>
  <elementSpec ident="beamSpan" module="MEI.cmn">
    <desc>(beam span) â€“ Alternative element for explicitly encoding beams, particularly those which
      extend across bar lines.</desc>
    <classes>
      <memberOf key="att.common"/>
      <memberOf key="att.facsimile"/>
      <memberOf key="att.beamSpan.log"/>
      <memberOf key="att.beamSpan.vis"/>
      <memberOf key="att.beamSpan.ges"/>
      <memberOf key="att.beamSpan.anl"/>
      <memberOf key="model.controlEventLike.cmn"/>
    </classes>
    <content>
      <rng:empty/>
    </content>
    <constraintSpec ident="beamspan_start-_and_end-type_attributes_required" scheme="isoschematron">
      <constraint>
        <sch:rule context="mei:beamSpan">
          <sch:assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one of the
            attributes: startid, tstamp, tstamp.ges or tstamp.real.</sch:assert>
          <sch:assert test="@dur or @dur.ges or @endid or @tstamp2">Must have one of the attributes:
            dur, dur.ges, endid, or tstamp2.</sch:assert>
        </sch:rule>
      </constraint>
    </constraintSpec>
    <remarks>
      <p>The starting point of the beam may be indicated by either a <att>startid</att>,
        <att>tstamp</att>, <att>tstamp.ges</att>, or <att>tstamp.real</att> attribute, while the
        ending point may be recorded by either a <att>dur</att>, <att>dur.ges</att>,
        <att>endid</att>, or <att>tstamp2</att> attribute. It is a semantic error not to specify one
        starting and one ending type of attribute.</p>
    </remarks>
  </elementSpec>
  <elementSpec ident="beatRpt" module="MEI.cmn">
    <desc>(beat repeat) â€“ An indication that material on a preceding beat should be repeated.</desc>
    <classes>
      <memberOf key="att.common"/>
      <memberOf key="att.facsimile"/>
      <memberOf key="att.beatRpt.log"/>
      <memberOf key="att.beatRpt.vis"/>
      <memberOf key="att.beatRpt.ges"/>
      <memberOf key="att.beatRpt.anl"/>
      <memberOf key="att.plist"/>
      <memberOf key="att.targetEval"/>
      <memberOf key="model.eventLike.cmn"/>
    </classes>
    <content>
      <rng:empty/>
    </content>
    <remarks>
      <p> <gi scheme="MEI">beatRpt</gi> may also be used in guitar or rhythm parts to indicate where
        chord changes occur. When these parts require durations longer or shorter than a beat;
        however, <gi scheme="MEI">note</gi> elements with appropriately-shaped note heads should be
        employed.</p>
    </remarks>
  </elementSpec>
  <elementSpec ident="bend" module="MEI.cmn">
    <desc>A variation in pitch (often micro-tonal) upwards or downwards during the course of a
      note.</desc>
    <classes>
      <memberOf key="att.common"/>
      <memberOf key="att.facsimile"/>
      <memberOf key="att.bend.log"/>
      <memberOf key="att.bend.vis"/>
      <memberOf key="att.bend.ges"/>
      <memberOf key="att.bend.anl"/>
      <memberOf key="model.controlEventLike"/>
    </classes>
    <content>
      <rng:empty/>
    </content>
    <constraintSpec ident="bend_start-_and_end-type_attributes_required" scheme="isoschematron">
      <constraint>
        <sch:rule context="mei:bend">
          <sch:assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one of the
            attributes: startid, tstamp, tstamp.ges or tstamp.real.</sch:assert>
          <sch:assert test="@dur or @dur.ges or @endid or @tstamp2">Must have one of the attributes:
            dur, dur.ges, endid, or tstamp2.</sch:assert>
        </sch:rule>
      </constraint>
    </constraintSpec>
  </elementSpec>
  <elementSpec ident="bracketSpan" module="MEI.cmn">
    <desc>Marks a sequence of notational events grouped by a bracket.</desc>
    <classes>
      <memberOf key="att.common"/>
      <memberOf key="att.bracketSpan.log"/>
      <memberOf key="att.bracketSpan.vis"/>
      <memberOf key="att.bracketSpan.ges"/>
      <memberOf key="att.bracketSpan.anl"/>
      <memberOf key="att.facsimile"/>
      <memberOf key="model.controlEventLike.cmn"/>
    </classes>
    <content>
      <rng:zeroOrMore>
        <rng:choice>
          <rng:text/>
          <rng:ref name="model.textPhraseLike.limited"/>
        </rng:choice>
      </rng:zeroOrMore>
    </content>
    <constraintSpec ident="bracketSpan_start-_and_end-type_attributes_required"
      scheme="isoschematron">
      <constraint>
        <sch:rule context="mei:bracketSpan">
          <sch:assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one of the
            attributes: startid, tstamp, tstamp.ges or tstamp.real.</sch:assert>
          <sch:assert test="@dur or @dur.ges or @endid or @tstamp2">Must have one of the attributes:
            dur, dur.ges, endid, or tstamp2.</sch:assert>
        </sch:rule>
      </constraint>
    </constraintSpec>
    <attList>
      <attDef ident="func" usage="req">
        <desc>Describes the function of the bracketed event sequence.</desc>
        <datatype>
          <rng:data type="NMTOKENS"/>
        </datatype>
        <valList type="semi">
          <valItem ident="coloration">
            <desc>Represents coloration in the mensural notation source material.</desc>
          </valItem>
          <valItem ident="cross-rhythm">
            <desc>Marks a sequence which does not match the current meter.</desc>
          </valItem>
          <valItem ident="ligature">
            <desc>Represents a ligature in the mensural notation source material.</desc>
          </valItem>
        </valList>
      </attDef>
    </attList>
    <remarks>
      <p>Text that interrupts the bracket used to mark the event group may be captured as the
        content of <gi scheme="MEI">bracketSpan</gi>. The starting point of the group/bracket may be
        indicated by either a <att>startid</att>, <att>tstamp</att>, <att>tstamp.ges</att>, or
        <att>tstamp.real</att> attribute, while the ending point may be recorded by either a
        <att>dur</att>, <att>dur.ges</att>, <att>endid</att>, or <att>tstamp2</att> attribute. It is
        a semantic error not to specify one starting and one ending type of attribute.</p>
    </remarks>
  </elementSpec>
  <elementSpec ident="breath" module="MEI.cmn">
    <desc>(breath mark) â€“ An indication of a point at which the performer on an instrument requiring
      breath (including the voice) may breathe.</desc>
    <classes>
      <memberOf key="att.common"/>
      <memberOf key="att.facsimile"/>
      <memberOf key="att.breath.log"/>
      <memberOf key="att.breath.vis"/>
      <memberOf key="att.breath.ges"/>
      <memberOf key="att.breath.anl"/>
      <memberOf key="model.controlEventLike.cmn"/>
    </classes>
    <content>
      <rng:empty/>
    </content>
    <constraintSpec ident="breath_start-type_attributes_required" scheme="isoschematron">
      <constraint>
        <sch:rule context="mei:breath">
          <sch:assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one of the
            attributes: startid, tstamp, tstamp.ges or tstamp.real.</sch:assert>
        </sch:rule>
      </constraint>
    </constraintSpec>
    <remarks>
      <p>This element may also indicate a short pause or break for instruments *not* requiring
        breath. In such cases, it functions as a guide to phrasing. The starting point of the breath
        mark may be indicated by either a <att>startid</att>, <att>tstamp</att>,
        <att>tstamp.ges</att>, or <att>tstamp.real</att> attribute. It is a semantic error not to
        specify a starting point attribute.</p>
      <p>Since the breath mark does not disrupt the normal tempo of a performance, it has no
        directly encode-able duration.</p>
      <p>The default value for <att>place</att> for a breath mark is "above". Unless indicated by
        other attributes, a breath mark will be rendered as a comma-like symbol above the top line
        of the staff.</p>
    </remarks>
  </elementSpec>
  <elementSpec ident="bTrem" module="MEI.cmn">
    <desc>(bowed tremolo) â€“ A rapid alternation on a single pitch or chord.</desc>
    <classes>
      <memberOf key="att.common"/>
      <memberOf key="att.facsimile"/>
      <memberOf key="att.bTrem.log"/>
      <memberOf key="att.bTrem.vis"/>
      <memberOf key="att.bTrem.ges"/>
      <memberOf key="att.bTrem.anl"/>
      <memberOf key="model.eventLike.cmn"/>
    </classes>
    <content>
      <rng:choice>
        <rng:ref name="chord"/>
        <rng:ref name="note"/>
      </rng:choice>
    </content>
  </elementSpec>
  <elementSpec ident="fermata" module="MEI.cmn">
    <desc>An indication placed over a note or rest to indicate that it should be held longer than
      its written value. May also occur over a bar line to indicate the end of a phrase or section.
      Sometimes called a 'hold' or 'pause'.</desc>
    <classes>
      <memberOf key="att.common"/>
      <memberOf key="att.facsimile"/>
      <memberOf key="att.fermata.log"/>
      <memberOf key="att.fermata.vis"/>
      <memberOf key="att.fermata.ges"/>
      <memberOf key="att.fermata.anl"/>
      <memberOf key="model.controlEventLike.cmn"/>
    </classes>
    <content>
      <rng:empty/>
    </content>
    <constraintSpec ident="fermata_start-type_attributes_required" scheme="isoschematron">
      <constraint>
        <sch:rule context="mei:fermata">
          <sch:assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one of the
            attributes: startid, tstamp, tstamp.ges or tstamp.real.</sch:assert>
        </sch:rule>
      </constraint>
    </constraintSpec>
    <remarks>
      <p>The <att>shape</att> attribute may be used to record whether the fermata is curved, square,
        or triangular, while <att>form</att> may be used to capture whether the fermata is
        "upright", i.e., has the curve or bracket above the dot, or inverted, i.e., has the curve or
        bracket below the dot. Other visual forms of a fermata may be indicated via the
        <att>altsym</att> attribute. The starting point of the fermata may be indicated by either a
        <att>startid</att>, <att>tstamp</att>, <att>tstamp.ges</att>, or <att>tstamp.real</att>
        attribute. It is a semantic error not to specify a starting point attribute.</p>
    </remarks>
  </elementSpec>
  <elementSpec ident="fTrem" module="MEI.cmn">
    <desc>(fingered tremolo) â€“ A rapid alternation between a pair of notes (or chords or perhaps
      between a note and a chord) that are (usually) farther apart than a major second.</desc>
    <classes>
      <memberOf key="att.common"/>
      <memberOf key="att.facsimile"/>
      <memberOf key="att.fTrem.log"/>
      <memberOf key="att.fTrem.vis"/>
      <memberOf key="att.fTrem.ges"/>
      <memberOf key="att.fTrem.anl"/>
      <memberOf key="model.eventLike.cmn"/>
    </classes>
    <content>
      <rng:choice>
        <rng:group>
          <rng:ref name="chord"/>
          <rng:choice>
            <rng:ref name="chord"/>
            <rng:ref name="note"/>
          </rng:choice>
        </rng:group>
        <rng:group>
          <rng:ref name="note"/>
          <rng:choice>
            <rng:ref name="chord"/>
            <rng:ref name="note"/>
          </rng:choice>
        </rng:group>
      </rng:choice>
    </content>
  </elementSpec>
  <elementSpec ident="gliss" module="MEI.cmn">
    <desc>(glissando) â€“ A continuous or sliding movement from one pitch to another, usually
      indicated by a straight or wavy line.</desc>
    <classes>
      <memberOf key="att.common"/>
      <memberOf key="att.facsimile"/>
      <memberOf key="att.gliss.log"/>
      <memberOf key="att.gliss.vis"/>
      <memberOf key="att.gliss.ges"/>
      <memberOf key="att.gliss.anl"/>
      <memberOf key="model.controlEventLike"/>
    </classes>
    <content>
      <rng:zeroOrMore>
        <rng:choice>
          <rng:text/>
          <rng:ref name="model.textPhraseLike.limited"/>
        </rng:choice>
      </rng:zeroOrMore>
    </content>
    <constraintSpec ident="gliss_start-_and_end-type_attributes_required" scheme="isoschematron">
      <constraint>
        <sch:rule context="mei:gliss">
          <sch:assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one of the
            attributes: startid, tstamp, tstamp.ges or tstamp.real.</sch:assert>
          <sch:assert test="@dur or @dur.ges or @endid or @tstamp2">Must have one of the attributes:
            dur, dur.ges, endid, or tstamp2.</sch:assert>
        </sch:rule>
      </constraint>
    </constraintSpec>
    <remarks>
      <p>Commonly also called a 'slide'. The term 'glissando' is frequently used to indicate both
        the case where distinct intermediate pitches are produced (as on the piano) and the case
        where they are not (as on the trombone), though the latter is sometimes referred to as
        'portamento'. The visual appearance of the indicating line may be recorded in the
        <att>lform</att> and <att>lwidth</att> attributes. The starting point of the glissando may
        be indicated by either a <att>startid</att>, <att>tstamp</att>, <att>tstamp.ges</att>, or
        <att>tstamp.real</att> attribute, while the ending point may be recorded by either a
        <att>dur</att>, <att>dur.ges</att>, <att>endid</att>, or <att>tstamp2</att> attribute. It is
        a semantic error not to specify one starting and one ending type of attribute.</p>
    </remarks>
  </elementSpec>
  <elementSpec ident="graceGrp" module="MEI.cmn">
    <desc>A container for a sequence of grace notes.</desc>
    <classes>
      <memberOf key="att.common"/>
      <memberOf key="att.facsimile"/>
      <memberOf key="att.graceGrp.log"/>
      <memberOf key="att.graceGrp.vis"/>
      <memberOf key="att.graceGrp.ges"/>
      <memberOf key="att.graceGrp.anl"/>
      <memberOf key="model.eventLike.cmn"/>
    </classes>
    <content>
      <rng:zeroOrMore>
        <rng:choice>
          <rng:ref name="model.eventLike"/>
          <rng:ref name="model.eventLike.cmn"/>
          <rng:ref name="model.appLike"/>
          <rng:ref name="model.editLike"/>
          <rng:ref name="model.transcriptionLike"/>
        </rng:choice>
      </rng:zeroOrMore>
    </content>
    <constraintSpec ident="When_not_copyof_graceGrp_content" scheme="isoschematron">
      <constraint>
        <sch:rule context="mei:graceGrp[not(@copyof)]">
          <sch:assert
            test="count(descendant::*[local-name()='note' or local-name()='rest' or               local-name()='chord' or local-name()='space']) &gt; 1"
            >A graceGrp without a copyof attribute must have at least 2 note, rest, chord, or space
            descendants.</sch:assert>
        </sch:rule>
      </constraint>
    </constraintSpec>
    <constraintSpec ident="When_graced" scheme="isoschematron">
      <constraint>
        <sch:rule context="mei:graceGrp[@grace]">
          <sch:assert test="not(descendant::mei:*[@grace])">The grace attribute is not allowed on
            descendants of a graceGrp with a grace attribute.</sch:assert>
        </sch:rule>
      </constraint>
    </constraintSpec>
  </elementSpec>
  <elementSpec ident="hairpin" module="MEI.cmn">
    <desc>Indicates continuous dynamics expressed on the score as wedge-shaped graphics, e.g. &lt;
      and &gt;.</desc>
    <classes>
      <memberOf key="att.common"/>
      <memberOf key="att.facsimile"/>
      <memberOf key="att.hairpin.log"/>
      <memberOf key="att.hairpin.vis"/>
      <memberOf key="att.hairpin.ges"/>
      <memberOf key="att.hairpin.anl"/>
      <memberOf key="model.controlEventLike.cmn"/>
    </classes>
    <content>
      <rng:empty/>
    </content>
    <constraintSpec ident="hairpin_start-_and_end-type_attributes_required" scheme="isoschematron">
      <constraint>
        <sch:rule context="mei:hairpin">
          <sch:assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one of the
            attributes: startid, tstamp, tstamp.ges or tstamp.real.</sch:assert>
          <sch:assert test="@dur or @dur.ges or @endid or @tstamp2">Must have one of the attributes:
            dur, dur.ges, endid, or tstamp2.</sch:assert>
        </sch:rule>
      </constraint>
    </constraintSpec>
    <remarks>
      <p>The <gi scheme="MEI">hairpin</gi> element is used for <emph>graphical</emph>, i.e.,
        crescendo and diminuendo, dynamic markings. For instantaneous or continuous
        <emph>textual</emph> dynamics, such as 'p', 'mf', or 'cres. poco a poco', the <gi
        scheme="MEI">dynam</gi> element should be used. The starting point of the hairpin marking
        may be indicated by either a <att>startid</att>, <att>tstamp</att>, <att>tstamp.ges</att>,
        or <att>tstamp.real</att> attribute, while the ending point may be recorded by either a
        <att>dur</att>, <att>dur.ges</att>, <att>endid</att>, or <att>tstamp2</att> attribute. It is
        a semantic error not to specify one starting and one ending type of attribute. MIDI values
        associated with the graphical dynamic sign may be recorded in the <att>val</att> and
        <att>val2</att> attributes.</p>
    </remarks>
  </elementSpec>
  <elementSpec ident="halfmRpt" module="MEI.cmn">
    <desc>(half-measure repeat) â€“ A half-measure repeat in any meter.</desc>
    <classes>
      <memberOf key="att.common"/>
      <memberOf key="att.facsimile"/>
      <memberOf key="att.halfmRpt.log"/>
      <memberOf key="att.halfmRpt.vis"/>
      <memberOf key="att.halfmRpt.ges"/>
      <memberOf key="att.halfmRpt.anl"/>
      <memberOf key="model.eventLike.cmn"/>
    </classes>
    <content>
      <rng:empty/>
    </content>
  </elementSpec>
  <elementSpec ident="harpPedal" module="MEI.cmn">
    <desc>(harp pedal) â€“ Harp pedal diagram.</desc>
    <classes>
      <memberOf key="att.common"/>
      <memberOf key="att.facsimile"/>
      <memberOf key="att.harpPedal.log"/>
      <memberOf key="att.harpPedal.vis"/>
      <memberOf key="att.harpPedal.ges"/>
      <memberOf key="att.harpPedal.anl"/>
      <memberOf key="model.controlEventLike.cmn"/>
    </classes>
    <content>
      <rng:empty/>
    </content>
    <constraintSpec ident="harpPedal_start-type_attributes_required" scheme="isoschematron">
      <constraint>
        <sch:rule context="mei:harpPedal">
          <sch:assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one of the
            attributes: startid, tstamp, tstamp.ges or tstamp.real.</sch:assert>
        </sch:rule>
      </constraint>
    </constraintSpec>
    <remarks>
      <p>The starting point of the harp pedal diagram may be indicated by either a
        <att>tstamp</att>, <att>tstamp.ges</att>, <att>tstamp.real</att> or <att>startid</att>
        attribute. It is a semantic error not to specify a starting point attribute.</p>
    </remarks>
  </elementSpec>
  <elementSpec ident="lv" module="MEI.cmn">
    <desc>A "tie-like" indication that a note should ring beyond its written duration.</desc>
    <classes>
      <memberOf key="att.common"/>
      <memberOf key="att.facsimile"/>
      <memberOf key="att.lv.log"/>
      <memberOf key="att.lv.vis"/>
      <memberOf key="att.lv.ges"/>
      <memberOf key="att.lv.anl"/>
      <memberOf key="model.controlEventLike.cmn"/>
    </classes>
    <content>
      <rng:zeroOrMore>
        <rng:ref name="curve"/>
      </rng:zeroOrMore>
    </content>
    <constraintSpec ident="lv_start-_and_end-type_attributes_required" scheme="isoschematron">
      <constraint>
        <sch:rule context="mei:lv">
          <sch:assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one of the
            attributes: startid, tstamp, tstamp.ges or tstamp.real.</sch:assert>
          <sch:assert test="@dur or @dur.ges or @endid or @tstamp2">Must have one of the attributes:
            dur, dur.ges, endid, or tstamp2.</sch:assert>
        </sch:rule>
      </constraint>
    </constraintSpec>
    <constraintSpec ident="lv_containing_curve" scheme="isoschematron">
      <constraint>
        <sch:rule
          context="mei:lv[mei:curve[@bezier or @bulge or @curvedir or @lform or @lwidth or              @ho or @startho or @endho or @to or @startto or @endto or @vo or @startvo or              @endvo or @x or @y or @x2 or @y2]]">
          <sch:assert
            test="not(@bezier or @bulge or @curvedir or @lform or @lwidth or @ho or @startho or                @endho or @to or @startto or @endto or @vo or @startvo or @endvo or @x or @y or @x2 or @y2)"
            role="warning">The visual attributes of the lv element (@bezier, @bulge, @curvedir,
            @lform, @lwidth, @ho, @startho, @endho, @to, @startto, @endto, @vo, @startvo, @endvo,
            @x, @y, @x2, and @y2) will be overridden by visual attributes of the contained curve
            elements.</sch:assert>
        </sch:rule>
      </constraint>
    </constraintSpec>
    <remarks>
      <p>The lv element captures the graphical, "tie-like" symbol. Any associated text, such as
        "l.v.", must be captured using a <gi scheme="MEI">dir</gi> element.</p>
    </remarks>
  </elementSpec>
  <elementSpec ident="measure" module="MEI.cmn">
    <desc>Unit of musical time consisting of a fixed number of note values of a given type, as
      determined by the prevailing meter, and delimited in musical notation by bar lines.</desc>
    <classes>
      <memberOf key="att.common"/>
      <memberOf key="att.facsimile"/>
      <memberOf key="att.metadataPointing"/>
      <memberOf key="att.pointing"/>
      <memberOf key="att.measure.anl"/>
      <memberOf key="att.measure.ges"/>
      <memberOf key="att.measure.log"/>
      <memberOf key="att.measure.vis"/>
      <memberOf key="att.targetEval"/>
      <memberOf key="model.measureLike"/>
    </classes>
    <content>
      <rng:optional>
        <rng:ref name="mNum"/>
      </rng:optional>
      <rng:zeroOrMore>
        <rng:choice>
          <rng:ref name="model.annotLike"/>
          <rng:ref name="model.appLike"/>
          <rng:ref name="model.editLike"/>
          <rng:ref name="model.graphicPrimitiveLike"/>
          <rng:ref name="model.measurePart"/>
          <rng:ref name="model.milestoneLike.music"/>
          <rng:ref name="model.relationLike"/>
          <rng:ref name="model.staffDefLike"/>
          <rng:ref name="model.transcriptionLike"/>
        </rng:choice>
      </rng:zeroOrMore>
    </content>
    <remarks>
      <p>In MEI, the <gi scheme="MEI">measure</gi> element is a grouping mechanism for events and
        control events. Pointing attributes make it possible to connect this element to other
        internal or external entities, such as media objects or annotations. The <att>width</att>
        attribute may be used to capture the width of the measure for interchange with music
        printing systems that utilize this information for printing.</p>
    </remarks>
  </elementSpec>
  <elementSpec ident="meterSig" module="MEI.cmn">
    <desc>(meter signature) â€“ Written meter signature.</desc>
    <classes>
      <memberOf key="att.common"/>
      <memberOf key="att.facsimile"/>
      <memberOf key="att.meterSig.anl"/>
      <memberOf key="att.meterSig.ges"/>
      <memberOf key="att.meterSig.log"/>
      <memberOf key="att.meterSig.vis"/>
      <memberOf key="model.meterSigLike"/>
    </classes>
    <content>
      <rng:empty/>
    </content>
  </elementSpec>
  <elementSpec ident="meterSigGrp" module="MEI.cmn">
    <desc>(meter signature group) â€“ Used to capture alternating, interchanging, and mixed meter
      signatures.</desc>
    <classes>
      <memberOf key="att.common"/>
      <memberOf key="att.facsimile"/>
      <memberOf key="att.meterSigGrp.anl"/>
      <memberOf key="att.meterSigGrp.ges"/>
      <memberOf key="att.meterSigGrp.log"/>
      <memberOf key="att.meterSigGrp.vis"/>
      <memberOf key="model.meterSigLike"/>
    </classes>
    <content>
      <rng:zeroOrMore>
        <rng:ref name="meterSig"/>
      </rng:zeroOrMore>
    </content>
    <constraintSpec ident="check_meterSigGrpContent" scheme="isoschematron">
      <constraint>
        <sch:rule context="mei:meterSigGrp[not(@copyof)]">
          <sch:assert test="count(mei:meterSig) &gt; 1">meterSigGrp must have at least 2 child
            meterSig elements.</sch:assert>
        </sch:rule>
      </constraint>
    </constraintSpec>
  </elementSpec>
  <elementSpec ident="mNum" module="MEI.cmn">
    <desc>(measure number) â€“ Designation, name, or label for a measure, often but not always
      consisting of digits. Use this element when the <att>n</att> attribute on <gi scheme="MEI"
      >measure</gi> does not adequately capture the appearance or placement of the measure
      number/label.</desc>
    <classes>
      <memberOf key="att.common"/>
      <memberOf key="att.facsimile"/>
      <memberOf key="att.lang"/>
      <memberOf key="att.mNum.log"/>
      <memberOf key="att.mNum.vis"/>
      <memberOf key="att.mNum.ges"/>
      <memberOf key="att.mNum.anl"/>
    </classes>
    <content>
      <rng:zeroOrMore>
        <rng:choice>
          <rng:text/>
          <rng:ref name="model.lbLike"/>
          <rng:ref name="model.rendLike"/>
        </rng:choice>
      </rng:zeroOrMore>
    </content>
    <remarks>
      <p> <gi scheme="MEI">mNum</gi> uses a subset of model.textPhraseLike.limited.</p>
    </remarks>
  </elementSpec>
  <elementSpec ident="mRest" module="MEI.cmn">
    <desc>(measure rest) â€“ Complete measure rest in any meter. <!-- (Read, p. 97-98). --> </desc>
    <classes>
      <memberOf key="att.common"/>
      <memberOf key="att.facsimile"/>
      <memberOf key="att.mRest.log"/>
      <memberOf key="att.mRest.vis"/>
      <memberOf key="att.mRest.ges"/>
      <memberOf key="att.mRest.anl"/>
      <memberOf key="model.eventLike.measureFilling"/>
    </classes>
    <content>
      <rng:empty/>
    </content>
    <remarks>
      <p>Automatically-generated numbering of consecutive measures of rest may be controlled via the
        <att>multi.number</att> attribute on the <gi scheme="MEI">scoreDef</gi> or <gi scheme="MEI"
        >staffDef</gi> elements.</p>
    </remarks>
  </elementSpec>
  <elementSpec ident="mRpt" module="MEI.cmn">
    <desc>(measure repeat) â€“ An indication that the previous measure should be repeated.</desc>
    <classes>
      <memberOf key="att.common"/>
      <memberOf key="att.facsimile"/>
      <memberOf key="att.mRpt.log"/>
      <memberOf key="att.mRpt.vis"/>
      <memberOf key="att.mRpt.ges"/>
      <memberOf key="att.mRpt.anl"/>
      <memberOf key="model.eventLike.measureFilling"/>
    </classes>
    <content>
      <rng:empty/>
    </content>
    <remarks>
      <p>The automated numbering of consecutive measures of rest may be controlled via the
        <att>multi.number</att> attribute on the <gi scheme="MEI">scoreDef</gi> or <gi scheme="MEI"
        >staffDef</gi> elements.</p>
    </remarks>
  </elementSpec>
  <elementSpec ident="mRpt2" module="MEI.cmn">
    <desc>(2-measure repeat) â€“ An indication that the previous two measures should be
      repeated.</desc>
    <classes>
      <memberOf key="att.common"/>
      <memberOf key="att.facsimile"/>
      <memberOf key="att.mRpt2.log"/>
      <memberOf key="att.mRpt2.vis"/>
      <memberOf key="att.mRpt2.ges"/>
      <memberOf key="att.mRpt2.anl"/>
      <memberOf key="model.eventLike.measureFilling"/>
    </classes>
    <content>
      <rng:empty/>
    </content>
  </elementSpec>
  <elementSpec ident="mSpace" module="MEI.cmn">
    <desc>(measure space) â€“ A measure containing only empty space in any meter.</desc>
    <classes>
      <memberOf key="att.common"/>
      <memberOf key="att.facsimile"/>
      <memberOf key="att.mSpace.log"/>
      <memberOf key="att.mSpace.vis"/>
      <memberOf key="att.mSpace.ges"/>
      <memberOf key="att.mSpace.anl"/>
      <memberOf key="model.eventLike.measureFilling"/>
    </classes>
    <content>
      <rng:empty/>
    </content>
    <remarks>
      <p>The automated numbering of consecutive measures of space may be controlled via the
        <att>multi.number</att> attribute on the <gi scheme="MEI">scoreDef</gi> or <gi scheme="MEI"
        >staffDef</gi> elements.</p>
    </remarks>
  </elementSpec>
  <elementSpec ident="multiRest" module="MEI.cmn">
    <desc>(multiple rest) â€“ Multiple measures of rest compressed into a single symbol, frequently
      found in performer parts.</desc>
    <classes>
      <memberOf key="att.common"/>
      <memberOf key="att.facsimile"/>
      <memberOf key="att.multiRest.log"/>
      <memberOf key="att.multiRest.vis"/>
      <memberOf key="att.multiRest.ges"/>
      <memberOf key="att.multiRest.anl"/>
      <memberOf key="model.eventLike.measureFilling"/>
    </classes>
    <content>
      <rng:empty/>
    </content>
    <!--<remarks><p>The num attribute can used to store a number to be rendered along with
        the note. See Read, p. 102-105.</p></remarks>-->
  </elementSpec>
  <elementSpec ident="multiRpt" module="MEI.cmn">
    <desc>(multiple repeat) â€“ Multiple repeated measures.</desc>
    <classes>
      <memberOf key="att.common"/>
      <memberOf key="att.facsimile"/>
      <memberOf key="att.multiRpt.log"/>
      <memberOf key="att.multiRpt.vis"/>
      <memberOf key="att.multiRpt.ges"/>
      <memberOf key="att.multiRpt.anl"/>
      <memberOf key="model.eventLike.measureFilling"/>
    </classes>
    <content>
      <rng:empty/>
    </content>
    <remarks>
      <p>In modern publishing practice, repeats of more than two measures should be written out
        using repeat signs. This element, however, is provided for handling non-standard practices
        often found in manuscript. The <att>num</att> attribute records the number of measures to be
        repeated.</p>
    </remarks>
  </elementSpec>
  <elementSpec ident="octave" module="MEI.cmn">
    <desc>An indication that a passage should be performed one or more octaves above or below its
      written pitch.</desc>
    <classes>
      <memberOf key="att.common"/>
      <memberOf key="att.facsimile"/>
      <memberOf key="att.octave.log"/>
      <memberOf key="att.octave.vis"/>
      <memberOf key="att.octave.ges"/>
      <memberOf key="att.octave.anl"/>
      <memberOf key="model.controlEventLike.cmn"/>
    </classes>
    <content>
      <rng:zeroOrMore>
        <rng:choice>
          <rng:text/>
          <rng:ref name="model.textPhraseLike.limited"/>
        </rng:choice>
      </rng:zeroOrMore>
    </content>
    <constraintSpec ident="octave_start-_and_end-type_attributes_required" scheme="isoschematron">
      <constraint>
        <sch:rule context="mei:octave">
          <sch:assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one of the
            attributes: startid, tstamp, tstamp.ges or tstamp.real.</sch:assert>
          <sch:assert test="@dur or @dur.ges or @endid or @tstamp2">Must have one of the attributes:
            dur, dur.ges, endid, or tstamp2.</sch:assert>
        </sch:rule>
      </constraint>
    </constraintSpec>
    <remarks>
      <p>The <att>dis</att> and <att>dis.place</att> attributes record the amount and direction of
        displacement, respectively. The <att>lform</att> and <att>lwidth</att> attributes capture
        the appearance of the continuation line associated with the octave displacement. The
        starting point of the octave displacement may be indicated by either a <att>startid</att>,
        <att>tstamp</att>, <att>tstamp.ges</att>, or <att>tstamp.real</att> attribute, while the
        ending point may be recorded by either a <att>dur</att>, <att>dur.ges</att>,
        <att>endid</att>, or <att>tstamp2</att> attribute. It is a semantic error not to specify one
        starting and one ending type of attribute. Also, note that the <att>dur</att> attribute is
        not required because the octave displacement can be visually instantaneous.</p>
    </remarks>
  </elementSpec>
  <elementSpec ident="oLayer" module="MEI.cmn">
    <desc>(ossia layer) â€“ A layer that contains an alternative to material in another layer.</desc>
    <classes>
      <memberOf key="att.basic"/>
      <memberOf key="att.facsimile"/>
      <memberOf key="att.labelled"/>
      <memberOf key="att.linking"/>
      <memberOf key="att.metadataPointing"/>
      <memberOf key="att.nInteger"/>
      <memberOf key="att.responsibility"/>
      <memberOf key="att.typed"/>
      <memberOf key="att.layer.log"/>
      <memberOf key="att.layer.vis"/>
      <memberOf key="att.layer.ges"/>
      <memberOf key="att.layer.anl"/>
    </classes>
    <content>
      <rng:zeroOrMore>
        <rng:choice>
          <rng:ref name="model.annotLike"/>
          <rng:ref name="model.appLike"/>
          <rng:ref name="model.editLike"/>
          <rng:ref name="model.graphicPrimitiveLike"/>
          <rng:ref name="model.layerPart"/>
          <rng:ref name="model.milestoneLike.music"/>
          <rng:ref name="model.transcriptionLike"/>
        </rng:choice>
      </rng:zeroOrMore>
    </content>
  </elementSpec>
  <elementSpec ident="ossia" module="MEI.cmn">
    <desc>Captures original notation and a differently notated version <hi rend="bold">*present in
      the source being transcribed*</hi>.</desc>
    <classes>
      <memberOf key="att.common"/>
      <memberOf key="att.facsimile"/>
      <memberOf key="att.ossia.log"/>
      <memberOf key="att.ossia.vis"/>
      <memberOf key="att.ossia.ges"/>
      <memberOf key="att.ossia.anl"/>
      <memberOf key="model.ossiaLike"/>
    </classes>
    <content>
      <rng:choice>
        <rng:group>
          <rng:oneOrMore>
            <rng:ref name="oStaff"/>
          </rng:oneOrMore>
          <rng:oneOrMore>
            <rng:ref name="model.staffLike"/>
          </rng:oneOrMore>
        </rng:group>
        <rng:group>
          <rng:oneOrMore>
            <rng:ref name="oLayer"/>
          </rng:oneOrMore>
          <rng:oneOrMore>
            <rng:ref name="model.layerLike"/>
          </rng:oneOrMore>
        </rng:group>
      </rng:choice>
    </content>
    <constraintSpec ident="Check_ossia" scheme="isoschematron">
      <constraint>
        <sch:pattern>
          <sch:rule context="mei:measure/mei:ossia">
            <sch:assert test="count(mei:*) = count(mei:staff)+count(mei:oStaff)">In a measure, ossia
              may only contain staff and oStaff elements.</sch:assert>
          </sch:rule>
          <sch:rule context="mei:staff/mei:ossia">
            <sch:assert test="count(mei:*) = count(mei:layer)+count(mei:oLayer)">In a staff, ossia
              may only contain layer and oLayer elements.</sch:assert>
          </sch:rule>
        </sch:pattern>
      </constraint>
    </constraintSpec>
    <remarks>
      <p>The alternative material in an ossia often provides a simpler, easier-to-perform option,
        while at other times the alternate material provides indications of performance practice,
        such as ornamentation. Often an ossia is rendered above the main staff on a reduced-size
        staff. Sometimes the alternate material occurs on the same staff as the primary text, but in
        a separate layer. In this case, the alternative material is often rendered in small-sized
        notation.</p>
    </remarks>
  </elementSpec>
  <elementSpec ident="oStaff" module="MEI.cmn">
    <desc>(ossia staff) â€“ A staff that holds an alternative passage which may be played instead of
      the original material.</desc>
    <classes>
      <memberOf key="att.basic"/>
      <memberOf key="att.facsimile"/>
      <memberOf key="att.labelled"/>
      <memberOf key="att.linking"/>
      <memberOf key="att.metadataPointing"/>
      <memberOf key="att.nInteger"/>
      <memberOf key="att.responsibility"/>
      <memberOf key="att.typed"/>
      <memberOf key="att.staff.log"/>
      <memberOf key="att.staff.vis"/>
      <memberOf key="att.staff.ges"/>
      <memberOf key="att.staff.anl"/>
    </classes>
    <content>
      <rng:zeroOrMore>
        <rng:choice>
          <rng:ref name="model.annotLike"/>
          <rng:ref name="model.appLike"/>
          <rng:ref name="model.editLike"/>
          <rng:ref name="model.graphicPrimitiveLike"/>
          <rng:ref name="model.milestoneLike.music"/>
          <rng:ref name="model.relationLike"/>
          <rng:ref name="model.staffDefLike"/>
          <rng:ref name="model.staffPart"/>
          <rng:ref name="model.transcriptionLike"/>
        </rng:choice>
      </rng:zeroOrMore>
    </content>
  </elementSpec>
  <elementSpec ident="pedal" module="MEI.cmn">
    <desc>Piano pedal mark.</desc>
    <classes>
      <memberOf key="att.common"/>
      <memberOf key="att.facsimile"/>
      <memberOf key="att.pedal.log"/>
      <memberOf key="att.pedal.vis"/>
      <memberOf key="att.pedal.ges"/>
      <memberOf key="att.pedal.anl"/>
      <memberOf key="model.controlEventLike.cmn"/>
    </classes>
    <content>
      <rng:empty/>
    </content>
    <constraintSpec ident="pedal_start-type_attributes_required" scheme="isoschematron">
      <constraint>
        <sch:rule context="mei:pedal">
          <sch:assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one of the
            attributes: startid, tstamp, tstamp.ges or tstamp.real.</sch:assert>
        </sch:rule>
      </constraint>
    </constraintSpec>
    <remarks>
      <p>The starting point of the pedal mark may be indicated by either a <att>startid</att>,
        <att>tstamp</att>, <att>tstamp.ges</att>, or <att>tstamp.real</att> attribute. It is a
        semantic error not to specify one of these attributes.</p>
    </remarks>
  </elementSpec>
  <elementSpec ident="reh" module="MEI.cmn">
    <desc>(rehearsal mark) â€“ In an orchestral score and its corresponding parts, a mark indicating a
      convenient point from which to resume rehearsal after a break.</desc>
    <classes>
      <memberOf key="att.common"/>
      <memberOf key="att.facsimile"/>
      <memberOf key="att.lang"/>
      <memberOf key="att.reh.log"/>
      <memberOf key="att.reh.vis"/>
      <memberOf key="att.reh.ges"/>
      <memberOf key="att.reh.anl"/>
      <memberOf key="model.controlEventLike.cmn"/>
    </classes>
    <content>
      <rng:zeroOrMore>
        <rng:choice>
          <rng:text/>
          <rng:ref name="model.lbLike"/>
          <rng:ref name="model.rendLike"/>
        </rng:choice>
      </rng:zeroOrMore>
    </content>
    <remarks>
      <p>It may also be called a "rehearsal figure", or when numbers are used instead of letters, a
        "rehearsal number". See Read, p. 443. <gi scheme="MEI">reh</gi> uses a subset of
        model.textPhraseLike.limited.</p>
    </remarks>
  </elementSpec>
  <elementSpec ident="slur" module="MEI.cmn">
    <desc>Indication of 1) a "unified melodic idea" or 2) performance technique.</desc>
    <classes>
      <memberOf key="att.common"/>
      <memberOf key="att.facsimile"/>
      <memberOf key="att.slur.log"/>
      <memberOf key="att.slur.vis"/>
      <memberOf key="att.slur.ges"/>
      <memberOf key="att.slur.anl"/>
      <memberOf key="model.controlEventLike.cmn"/>
    </classes>
    <content>
      <rng:zeroOrMore>
        <rng:ref name="curve"/>
      </rng:zeroOrMore>
    </content>
    <constraintSpec ident="slur_start-_and_end-type_attributes_required" scheme="isoschematron">
      <constraint>
        <sch:rule context="mei:slur">
          <sch:assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one of the
            attributes: startid, tstamp, tstamp.ges or tstamp.real.</sch:assert>
          <sch:assert test="@dur or @dur.ges or @endid or @tstamp2">Must have one of the attributes:
            dur, dur.ges, endid, or tstamp2.</sch:assert>
        </sch:rule>
      </constraint>
    </constraintSpec>
    <constraintSpec ident="slur_containing_curve" scheme="isoschematron">
      <constraint>
        <sch:rule
          context="mei:slur[mei:curve[@bezier or @bulge or @curvedir or @lform or @lwidth or              @ho or @startho or @endho or @to or @startto or @endto or @vo or @startvo or @endvo or              @x or @y or @x2 or @y2]]">
          <sch:assert
            test="not(@bezier or @bulge or @curvedir or @lform or @lwidth or @ho or @startho or                @endho or @to or @startto or @endto or @vo or @startvo or @endvo or @x or @y or @x2 or @y2)"
            role="warning">The visual attributes of the slur (@bezier, @bulge, @curvedir, @lform,
            @lwidth, @ho, @startho, @endho, @to, @startto, @endto, @vo, @startvo, @endvo, @x, @y,
            @x2, and @y2) will be overridden by visual attributes of the contained curve
            elements.</sch:assert>
        </sch:rule>
      </constraint>
    </constraintSpec>
    <remarks>
      <p>Historically, the term "slur" indicated two notes performed legato, while the term "phrase"
        was used for a "unified melodic idea". Nowadays, however, "slur" often has the same meaning
        as "phrase" (See Read, p. 265-266), since the visual rendition of the two concepts is the
        same. MEI provides two distinct elements so that those users wishing to maintain a
        distinction for historical reasons may do so. If the user does not want to maintain the
        distinction, then the more generic <gi scheme="MEI">slur</gi> element should be employed.
        The starting point of the phrase/slur may be indicated by either a <att>startid</att>,
        <att>tstamp</att>, <att>tstamp.ges</att>, or <att>tstamp.real</att> attribute, while the
        ending point may be recorded by either a <att>dur</att>, <att>dur.ges</att>,
        <att>endid</att>, or <att>tstamp2</att> attribute. It is a semantic error not to specify one
        starting and one ending type of attribute. Either <att>place</att>, <att>bulge</att>, or
        <att>bezier</att> attributes may be used to record the curvature of the phrase/slur. The <gi
        scheme="MEI">slur</gi> and <gi scheme="MEI">tie</gi> elements may be used instead of the
        slur.* and tie.* attributes provided on <gi scheme="MEI">chord</gi> and <gi scheme="MEI"
        >note</gi> elements when 1) they are required by software, or 2) multiple, alternative slurs
        are needed.</p>
    </remarks>
  </elementSpec>
  <elementSpec ident="tie" module="MEI.cmn">
    <desc>An indication that two notes of the same pitch form a single note with their combined
      rhythmic values.</desc>
    <classes>
      <memberOf key="att.common"/>
      <memberOf key="att.facsimile"/>
      <memberOf key="att.tie.log"/>
      <memberOf key="att.tie.vis"/>
      <memberOf key="att.tie.ges"/>
      <memberOf key="att.tie.anl"/>
      <memberOf key="model.controlEventLike.cmn"/>
    </classes>
    <content>
      <rng:zeroOrMore>
        <rng:ref name="curve"/>
      </rng:zeroOrMore>
    </content>
    <constraintSpec ident="tie_start-_and_end-type_attributes_required" scheme="isoschematron">
      <constraint>
        <sch:rule context="mei:tie">
          <sch:assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one of the
            attributes: startid, tstamp, tstamp.ges or tstamp.real.</sch:assert>
          <sch:assert test="@dur or @dur.ges or @endid or @tstamp2">Must have one of the attributes:
            dur, dur.ges, endid, or tstamp2.</sch:assert>
        </sch:rule>
      </constraint>
    </constraintSpec>
    <constraintSpec ident="tie_containing_curve" scheme="isoschematron">
      <constraint>
        <sch:rule
          context="mei:tie[mei:curve[@bezier or @bulge or @curvedir or @lform or @lwidth or              @ho or @startho or @endho or @to or @startto or @endto or @vo or @startvo or              @endvo or @x or @y or @x2 or @y2]]">
          <sch:assert
            test="not(@bezier or @bulge or @curvedir or @lform or @lwidth or @ho or @startho or                @endho or @to or @startto or @endto or @vo or @startvo or @endvo or @x or @y or @x2 or @y2)"
            role="warning">The visual attributes of the tie (@bezier, @bulge, @curvedir, @lform,
            @lwidth, @ho, @startho, @endho, @to, @startto, @endto, @vo, @startvo, @endvo, @x, @y,
            @x2, and @y2) will be overridden by visual attributes of the contained curve
            elements.</sch:assert>
        </sch:rule>
      </constraint>
    </constraintSpec>
    <remarks>
      <p>Most often, a tie is rendered as a curved line connecting the two notes. See Read, p.
        110-111, 122.</p>
    </remarks>
  </elementSpec>
  <elementSpec ident="tuplet" module="MEI.cmn">
    <desc>A group of notes with "irregular" (sometimes called "irrational") rhythmic values, for
      example, three notes in the time normally occupied by two or nine in the time of five.</desc>
    <classes>
      <memberOf key="att.common"/>
      <memberOf key="att.facsimile"/>
      <memberOf key="att.tuplet.log"/>
      <memberOf key="att.tuplet.vis"/>
      <memberOf key="att.tuplet.ges"/>
      <memberOf key="att.tuplet.anl"/>
      <memberOf key="model.eventLike.cmn"/>
    </classes>
    <content>
      <rng:zeroOrMore>
        <rng:choice>
          <rng:ref name="model.appLike"/>
          <rng:ref name="model.editLike"/>
          <rng:ref name="model.eventLike"/>
          <rng:ref name="model.eventLike.cmn"/>
          <rng:ref name="model.transcriptionLike"/>
        </rng:choice>
      </rng:zeroOrMore>
    </content>
    <constraintSpec ident="When_not_copyof_tuplet_content" scheme="isoschematron">
      <constraint>
        <sch:rule context="mei:tuplet[not(@copyof)]">
          <sch:assert
            test="count(descendant::*[local-name()='note' or local-name()='rest' or               local-name()='chord']) &gt; 1"
            >A tuplet without a copyof attribute must have at least 2 note, rest, or chord
            descendants.</sch:assert>
        </sch:rule>
      </constraint>
    </constraintSpec>
    <remarks>
      <p>The <gi scheme="MEI">beam</gi> sub-element is allowed so that custom beaming may be
        indicated, e.g., a septuplet may be divided into a group of three plus a group of four
        notes. See Read, p. 187-215. The <gi scheme="MEI">tuplet</gi> element may also used for
        bowed tremolo (Read, p. 394) and double, triple, or flutter tonguing (Read, p. 348-349);
        that is, for repetition of the same pitch. In the case of irrational durations, such as such
        as two quarter notes in the time of five 8th notes in a measure of 5/8 time, decimal values
        may be used in the <att>dur.ges</att> attribute. For example, the <att>dur.ges</att>
        attribute would take the value "2.5" if the <att>midi.div</att> attribute's value was "1".
        The <att>num</att> and <att>numbase</att> attributes may be used for explicit labelling of a
        tuplet, such as, '3' with an 8th-note triplet, '3:2' over a quarter-note triplet, etc. The
        rendering of the ratio, however, is dependent on the <att>num.format</att> attribute found
        in the att.vis.tuplet attribute class.</p>
    </remarks>
  </elementSpec>
  <elementSpec ident="tupletSpan" module="MEI.cmn">
    <desc>(tuplet span) â€“ Alternative element for encoding tuplets, especially useful for tuplets
      that extend across bar lines.</desc>
    <classes>
      <memberOf key="att.common"/>
      <memberOf key="att.facsimile"/>
      <memberOf key="att.tupletSpan.log"/>
      <memberOf key="att.tupletSpan.vis"/>
      <memberOf key="att.tupletSpan.ges"/>
      <memberOf key="att.tupletSpan.anl"/>
      <memberOf key="model.controlEventLike.cmn"/>
    </classes>
    <content>
      <rng:empty/>
    </content>
    <constraintSpec ident="tupletSpan_start-_and_end-type_attributes_required"
      scheme="isoschematron">
      <constraint>
        <sch:rule context="mei:tupletSpan">
          <sch:assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one of the
            attributes: startid, tstamp, tstamp.ges or tstamp.real.</sch:assert>
          <sch:assert test="@dur or @dur.ges or @endid or @tstamp2">Must have one of the attributes:
            dur, dur.ges, endid, or tstamp2.</sch:assert>
        </sch:rule>
      </constraint>
    </constraintSpec>
    <remarks>
      <p>The starting point of the tuplet may be indicated by either a <att>startid</att>,
        <att>tstamp</att>, <att>tstamp.ges</att>, or <att>tstamp.real</att> attribute, while the
        ending point may be recorded by either a <att>dur</att>, <att>dur.ges</att>,
        <att>endid</att>, or <att>tstamp2</att> attribute. It is a semantic error not to specify one
        starting and one ending type of attribute.</p>
    </remarks>
  </elementSpec>
</specGrp>
