<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:math="http://www.w3.org/2005/xpath-functions/math"
    xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl"
    xmlns:tei="http://www.tei-c.org/ns/1.0"
    xmlns:egx="http://www.tei-c.org/ns/Examples"
    xmlns:xhtml="http://www.w3.org/1999/xhtml"
    xmlns:rng="http://relaxng.org/ns/structure/1.0"
    xmlns:sch="http://purl.oclc.org/dsdl/schematron"
    xmlns:local="no:where"
    exclude-result-prefixes="xs math xd xhtml tei local rng sch egx"
    version="3.0">
    <xd:doc scope="stylesheet">
        <xd:desc>
            <xd:p><xd:b>Created on:</xd:b> Dec 12, 2015</xd:p>
            <xd:p><xd:b>Author:</xd:b> Johannes Kepper</xd:p>
            <xd:p>This XSL generates the website version of the MEI Guidelines, directly from a canonicalized ODD file.</xd:p>
            <xd:p><xd:b>2020-11-10:</xd:b> This is the XSLT that has been used before the transition to MarkDown. It does work surprisingly well, 
                but surely needs a lot of adjustments, and will be mixed with XSLT that has been used with the MarkDown version of the Guidelines.</xd:p>
        </xd:desc>
    </xd:doc>
    <xsl:output indent="yes" method="xhtml"/>
    <xsl:param name="version" select="//tei:classSpec[@ident = ('att.meiversion','att.meiVersion')]//tei:defaultVal/text()" as="xs:string"/>
    
    <xd:doc scope="component">
        <xd:desc>
            <xd:p>
                $target describes the intended target medium of this documentation. Allowed values are
                'website' and 'pdf'. 'website' aims at music-encoding.org, with a whole bunch of resulting 
                files to be uploaded to the website through an administrator with direct access to the file
                system. 'pdf' generates a single HTML file to be used either standalone or as input to
                PrinceXML, which generates a PDF from the HTML. 
            </xd:p>
        </xd:desc>
    </xd:doc>
    <xsl:param name="target" select="'pdf'" as="xs:string"/>
    
    <xd:doc scope="component">
        <xd:desc>
            <xd:p>
                $role describes the role of the output:
                'release' qualifies this as official release of MEI, using the version number provided.
                'custom' qualifies this as output of a customization of MEI
                'dev' qualifies this as development version of MEI, taken from the official repo.
                
                This param is used for a running header in PDF output.
            </xd:p>
        </xd:desc>
    </xd:doc>
    <xsl:param name="role" select="'dev'" as="xs:string"/>
    
    <xd:doc scope="component">
        <xd:desc>
            <xd:p>
                $image.prefix is a general prefix prepended to all image paths generated by this stylesheet.
            </xd:p>
        </xd:desc>
    </xd:doc>
    <xsl:param name="image.prefix" as="xs:string">
        <xsl:choose>
            <xsl:when test="$target = 'website'">
                <xsl:value-of select="'../../../../guidelines/3.0.0/'"/>
            </xsl:when>
            <xsl:when test="$target = 'pdf'">
                <xsl:value-of select="'./'"/>
            </xsl:when>
        </xsl:choose>
    </xsl:param>
    
    <xsl:param name="imprint.date" select="substring(string(current-date()),1,4)" as="xs:string"/>
    
    
    <!-- start of processing -->
    
    <xd:doc scope="component">
        <xd:desc>
            <xd:p>
                $supported.version contains reference strings for every supported MEI version. 
                The only use of this variable is to indicate a mismatch between it and the 
                $version variable in a message, but nothing else happens. 
                Nevertheless, if adjusted to newer versions of MEI, these version numbers 
                should be added below. 
            </xd:p>
        </xd:desc>
    </xd:doc>
    <xsl:variable name="supported.version" as="xs:string+">
        <xsl:value-of select="'3.0.0'"/>
        <!-- fill in further MEI version, for which this xsl has been adjusted -->
    </xsl:variable>
    
    <xsl:variable name="outPutFolder" select="'./' || $version || '/'" as="xs:string"/>
    
    <xsl:variable name="mei.source" select="/" as="node()"/>
    
    <xsl:variable name="chapters" select="//tei:body//tei:div[@type = 'div1']" as="node()*"/>
    
    <xsl:variable name="all.chapters" as="node()*">
        <chapters>
            <xsl:for-each select="//tei:body/tei:div">
                <xsl:variable name="chapter1" select="." as="node()"/>
                <xsl:variable name="level1.index" select="position()" as="xs:integer"/>
                <chapter level="1" xml:id="{$chapter1/@xml:id}" number="{$level1.index}" head="{$chapter1/tei:head/text()}"/>
                
                <xsl:for-each select="child::tei:div">
                    <xsl:variable name="chapter2" select="." as="node()"/>
                    <xsl:variable name="level2.index" select="position()" as="xs:integer"/>
                    <chapter level="2" xml:id="{$chapter2/@xml:id}" number="{$level1.index}.{$level2.index}" head="{$chapter2/tei:head/text()}" parent.id="{$chapter1/@xml:id}"/>
                    
                    <xsl:for-each select="child::tei:div">
                        <xsl:variable name="chapter3" select="." as="node()"/>
                        <xsl:variable name="level3.index" select="position()" as="xs:integer"/>
                        <chapter level="3" xml:id="{$chapter3/@xml:id}" number="{$level1.index}.{$level2.index}.{$level3.index}" head="{$chapter3/tei:head/text()}" parent.id="{$chapter2/@xml:id}"/>
                        
                        <xsl:for-each select="child::tei:div">
                            <xsl:variable name="chapter4" select="." as="node()"/>
                            <xsl:variable name="level4.index" select="position()" as="xs:integer"/>
                            <chapter level="4" xml:id="{$chapter4/@xml:id}" number="{$level1.index}.{$level2.index}.{$level3.index}.{$level4.index}" head="{$chapter4/tei:head/text()}" parent.id="{$chapter3/@xml:id}"/>
                            
                            <xsl:for-each select="child::tei:div">
                                <xsl:variable name="chapter5" select="." as="node()"/>
                                <xsl:variable name="level5.index" select="position()" as="xs:integer"/>
                                <chapter level="5" xml:id="{$chapter5/@xml:id}" number="{$level1.index}.{$level2.index}.{$level3.index}.{$level4.index}.{$level5.index}" head="{$chapter5/tei:head/text()}" parent.id="{$chapter4/@xml:id}"/>
                            </xsl:for-each>
                            
                        </xsl:for-each>
                        
                    </xsl:for-each>
                    
                </xsl:for-each>
                
            </xsl:for-each>
        </chapters>
    </xsl:variable>
    
    <xsl:variable name="elements" as="node()*">
        <xsl:for-each select="//tei:elementSpec">
            <xsl:sort select="@ident" data-type="text"/>
            <xsl:sequence select="."/>
        </xsl:for-each>
    </xsl:variable>    
    <xsl:variable name="model.classes" as="node()*">
        <xsl:for-each select="//tei:classSpec[@type = 'model']">
            <xsl:sort select="@ident" data-type="text"/>
            <xsl:sequence select="."/>
        </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="att.classes" as="node()*">
        <xsl:for-each select="//tei:classSpec[@type = 'atts']">
            <xsl:sort select="@ident" data-type="text"/>
            <xsl:sequence select="."/>
        </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="data.types" as="node()*">
        <xsl:for-each select="//tei:macroSpec">
            <xsl:sort select="@ident" data-type="text"/>
            <xsl:sequence select="."/>
        </xsl:for-each>
    </xsl:variable>
    
    <xsl:template match="/">
        
        <xsl:message terminate="no" select="'INFO: Extracting Guidelines for ' || $target || ' publication from MEI source (version ' || $version || ')'"/>
        
        <xsl:if test="not($version = $supported.version)">
            <xsl:message terminate="no" select="'WARNING: This version of MEI is not officially supported. Please check the results carefully.'"/>
        </xsl:if>
        
        <!-- chapters -->
        <xsl:message select="'INFO: Resolving ' || count($chapters) || ' chapters.'"/>
        <xsl:variable name="chapterLinks" as="node()*">
            <xsl:for-each select="$chapters">
                <xsl:variable name="name" select="@xml:id"/>
                <xsl:variable name="heading" select="./tei:head[1]/text()"/>
                <xsl:variable name="headingNo" select="concat(position(),'.')"/>
                <a class="module" href="/documentation/{$version}/{$name}">
                    <span class="no"><xsl:value-of select="$headingNo"/></span>
                    <span class="title"><xsl:value-of select="$heading"/></span></a>
            </xsl:for-each>
        </xsl:variable>
        
        <!-- elements -->
        <xsl:message select="'INFO: Resolving ' || count($elements) || ' elements.'"/>
        <xsl:variable name="elementLinks" as="node()*">
            <xsl:for-each select="$elements">
                <xsl:sort select="@ident" data-type="text"/>
                <xsl:variable name="name" select="@ident"/>
                <xsl:variable name="heading" select="$name"/>
                <a class="link_odd_elementSpec {substring($name,1,1)}" href="/documentation/{$version}/{$name}"><xsl:value-of select="$heading"/></a>
            </xsl:for-each>
        </xsl:variable>
        
        <!-- model classes -->
        <xsl:message select="'INFO: Resolving ' || count($model.classes) || ' model classes.'"/>
        <xsl:variable name="modelLinks" as="node()*">
            <xsl:for-each select="$model.classes">
                <xsl:sort select="@ident" data-type="text"/>
                <xsl:variable name="name" select="@ident"/>
                <xsl:variable name="heading" select="$name"/>
                <a class="link_odd_classSpec {substring($name,7,1)}" href="/documentation/{$version}/{$name}"><xsl:value-of select="$heading"/></a><br/>
            </xsl:for-each>
        </xsl:variable>
        
        <!-- attribute classes -->
        <xsl:message select="'INFO: Resolving ' || count($att.classes) || ' attribute classes.'"/>
        <xsl:variable name="attLinks" as="node()*">
            <xsl:for-each select="$att.classes">
                <xsl:sort select="@ident" data-type="text"/>
                <xsl:variable name="name" select="@ident"/>
                <xsl:variable name="heading" select="$name"/>
                <a class="link_odd {substring($name,5,1)}" href="/documentation/{$version}/{$name}"><xsl:value-of select="$heading"/></a><br/>
            </xsl:for-each>
        </xsl:variable>
        
        <!-- data types and macros -->
        <xsl:message select="'INFO: Resolving ' || count($data.types) || ' data types.'"/>
        <xsl:variable name="dataLinks" as="node()*">
            <xsl:for-each select="$data.types">
                <xsl:variable name="name" select="@ident"/>
                <xsl:variable name="heading" select="$name"/>
                <a class="link_odd {if(starts-with($name,'macro')) then(substring($name,7,1)) else(substring($name,6,1))}" href="/documentation/{$version}/{$name}"><xsl:value-of select="$heading"/></a><br/>
            </xsl:for-each>
        </xsl:variable>
        
        <!-- decide how to output things -->
        <xsl:choose>
            <xsl:when test="$target = 'website'">
                <xsl:message select="'INFO: Building multiple HTML fragments for inclusion on music-encoding.org'"/>
                <!-- chapter overview -->
                <xsl:result-document href="{$outPutFolder}chapters.xml">
                    <xsl:call-template name="generateCategoryOverview">
                        <xsl:with-param name="items" select="$chapterLinks" as="node()*"/>
                        <xsl:with-param name="mode" select="'chapters'" as="xs:string"/>
                    </xsl:call-template>
                </xsl:result-document>
                <xsl:call-template name="processItems">
                    <xsl:with-param name="items" select="$chapters" as="node()*"/>
                    <xsl:with-param name="itemLinks" select="$chapterLinks" as="node()*"/>
                    <xsl:with-param name="mode" select="'chapters'" as="xs:string"/>
                </xsl:call-template>
                <!-- elements overview -->
                <xsl:result-document href="{$outPutFolder}elements.xml">
                    <xsl:call-template name="generateCategoryOverview">
                        <xsl:with-param name="items" select="$elementLinks" as="node()*"/>
                        <xsl:with-param name="mode" select="'elements'" as="xs:string"/>
                    </xsl:call-template>
                </xsl:result-document>
                <xsl:call-template name="processItems">
                    <xsl:with-param name="items" select="$elements" as="node()*"/>
                    <xsl:with-param name="itemLinks" select="$elementLinks" as="node()*"/>
                    <xsl:with-param name="mode" select="'elements'" as="xs:string"/>
                </xsl:call-template>
                <!-- model overview -->
                <xsl:result-document href="{$outPutFolder}models.xml">
                    <xsl:call-template name="generateCategoryOverview">
                        <xsl:with-param name="items" select="$modelLinks" as="node()*"/>
                        <xsl:with-param name="mode" select="'models'" as="xs:string"/>
                    </xsl:call-template>
                </xsl:result-document>
                <xsl:call-template name="processItems">
                    <xsl:with-param name="items" select="$model.classes" as="node()*"/>
                    <xsl:with-param name="itemLinks" select="$modelLinks" as="node()*"/>
                    <xsl:with-param name="mode" select="'models'" as="xs:string"/>
                </xsl:call-template>
                <!-- attribute overview -->
                <xsl:result-document href="{$outPutFolder}atts.xml">
                    <xsl:call-template name="generateCategoryOverview">
                        <xsl:with-param name="items" select="$attLinks" as="node()*"/>
                        <xsl:with-param name="mode" select="'atts'" as="xs:string"/>
                    </xsl:call-template>
                </xsl:result-document>
                <xsl:call-template name="processItems">
                    <xsl:with-param name="items" select="$att.classes" as="node()*"/>
                    <xsl:with-param name="itemLinks" select="$attLinks" as="node()*"/>
                    <xsl:with-param name="mode" select="'atts'" as="xs:string"/>
                </xsl:call-template>
                <!-- data type overview -->
                <xsl:result-document href="{$outPutFolder}data.xml">
                    <xsl:call-template name="generateCategoryOverview">
                        <xsl:with-param name="items" select="$dataLinks" as="node()*"/>
                        <xsl:with-param name="mode" select="'dataMacros'" as="xs:string"/>
                    </xsl:call-template>
                </xsl:result-document>
                <xsl:call-template name="processItems">
                    <xsl:with-param name="items" select="$data.types" as="node()*"/>
                    <xsl:with-param name="itemLinks" select="$dataLinks" as="node()*"/>
                    <xsl:with-param name="mode" select="'dataMacros'" as="xs:string"/>
                </xsl:call-template>    
            </xsl:when>
            <xsl:when test="$target = 'pdf'">
                <xsl:message select="'INFO: Building single HTML document for conversion to PDF'"/>
                <xsl:variable name="contents" as="node()*">
                    <xsl:call-template name="processItems">
                        <xsl:with-param name="items" select="$chapters" as="node()*"/>
                        <xsl:with-param name="itemLinks" select="$chapterLinks" as="node()*"/>
                        <xsl:with-param name="mode" select="'chapters'" as="xs:string"/>
                    </xsl:call-template>
                    <xsl:call-template name="processItems">
                        <xsl:with-param name="items" select="$elements" as="node()*"/>
                        <xsl:with-param name="itemLinks" select="$elementLinks" as="node()*"/>
                        <xsl:with-param name="mode" select="'elements'" as="xs:string"/>
                    </xsl:call-template>
                    <xsl:call-template name="processItems">
                        <xsl:with-param name="items" select="$model.classes" as="node()*"/>
                        <xsl:with-param name="itemLinks" select="$modelLinks" as="node()*"/>
                        <xsl:with-param name="mode" select="'models'" as="xs:string"/>
                    </xsl:call-template>
                    <xsl:call-template name="processItems">
                        <xsl:with-param name="items" select="$att.classes" as="node()*"/>
                        <xsl:with-param name="itemLinks" select="$attLinks" as="node()*"/>
                        <xsl:with-param name="mode" select="'atts'" as="xs:string"/>
                    </xsl:call-template>
                    <xsl:call-template name="processItems">
                        <xsl:with-param name="items" select="$data.types" as="node()*"/>
                        <xsl:with-param name="itemLinks" select="$dataLinks" as="node()*"/>
                        <xsl:with-param name="mode" select="'dataMacros'" as="xs:string"/>
                    </xsl:call-template>    
                </xsl:variable>
                
                <xsl:result-document href="MEI_Guidelines_v{$version}.html">
                    <xsl:call-template name="getSinglePage">
                        <xsl:with-param name="contents" select="$contents" as="node()*"/>
                    </xsl:call-template>
                </xsl:result-document>
            </xsl:when>
        </xsl:choose>
        
    </xsl:template>
    
    
    <!-- generate overview pages for each category -->
    <xsl:template name="generateCategoryOverview" as="node()">
        <xsl:param name="items" as="node()*"/>
        <xsl:param name="mode" as="xs:string"/>
        
        <div>
            <article class="page type-page status-publish hentry">
                <div class="entry-content">
                    <div class="panel-grid">
                        <div class="panel-grid-cell" style="width: 65%; float: left;">
                            <div class="panel widget widget_text panel-first-child panel-last-child">
                                <xsl:choose>
                                    <xsl:when test="$mode = 'chapters'">
                                        <h3 class="widget-title">Table of Contents</h3>
                                        <div class="textwidget">
                                            <ul class="guidelinesList">
                                                <xsl:for-each select="$items">
                                                    <li><xsl:copy-of select="."/></li>
                                                </xsl:for-each>
                                            </ul>
                                        </div>
                                    </xsl:when>
                                    <xsl:when test="$mode = ('elements','models','atts')">
                                        <h3 class="widget-title">
                                            <xsl:choose>
                                                <xsl:when test="$mode = 'elements'">MEI Elements</xsl:when>
                                                <xsl:when test="$mode = 'models'">MEI Model Classes</xsl:when>
                                                <xsl:when test="$mode = 'atts'">MEI Attribute Classes</xsl:when>
                                            </xsl:choose>
                                        </h3>
                                        <div class="textwidget">
                                            <xsl:for-each select="(97 to 122)">
                                                <xsl:variable name="key" select="codepoints-to-string(.)"/>
                                                <xsl:variable name="links" select="$items/descendant-or-self::a[ends-with(@class,$key)]"/>
                                                
                                                <xsl:if test="count($links) gt 0">
                                                    <div class="sortedInitials well {$key}">
                                                        <h3><xsl:value-of select="$key"/></h3>
                                                        <xsl:copy-of select="$links"/>
                                                    </div>
                                                </xsl:if>
                                            </xsl:for-each>
                                        </div>
                                    </xsl:when>
                                    <xsl:when test="$mode = 'dataMacros'">
                                        <h3 class="widget-title">MEI Data Types and Macros</h3>
                                        <div class="textwidget">
                                            <xsl:for-each select="(65 to 90)">
                                                <xsl:variable name="key" select="codepoints-to-string(.)"/>
                                                <xsl:variable name="links" select="$items/descendant-or-self::a[ends-with(@class,$key)]"/>
                                                
                                                <xsl:if test="count($links) gt 0">
                                                    <div class="sortedInitials well {$key}">
                                                        <h3><xsl:value-of select="lower-case($key)"/></h3>
                                                        <xsl:copy-of select="$links"/>
                                                    </div>
                                                </xsl:if>
                                                
                                            </xsl:for-each>
                                            
                                            <xsl:variable name="macros" select="$items/descendant-or-self::a[starts-with(./text(),'macro.')]"/>
                                            <xsl:if test="count($macros) gt 0">
                                                <div class="sortedInitials well macros">
                                                    <h3>Macros</h3>
                                                    <xsl:copy-of select="$macros"/>
                                                </div>
                                            </xsl:if>
                                        </div>
                                    </xsl:when>
                                </xsl:choose>
                            </div>
                        </div>
                        <div class="panel-grid-cell" style="width: 35%; float: left;">
                            <div class="panel widget widget_text panel-first-child panel-last-child">
                                <xsl:call-template name="getPrimarySideNav"/>
                            </div>
                        </div>
                    </div>
                </div>
            </article>
        </div>
        
    </xsl:template>
    
    <!-- get primary sidebar navigation -->
    <xsl:template name="getPrimarySideNav" as="node()*">
        <header class="entry-header">
            <h1 class="entry-title">
                MEI Guidelines <small>Version <xsl:value-of select="$version"/></small>
            </h1>				
        </header>
        <div class="textwidget">
            <ul class="guidelinesList">
                <li><a class="guidelines_mainLink" href="/documentation/{$version}/chapters">MEI Guidelines</a></li>
                <li><a class="guidelines_mainLink" href="/documentation/{$version}/elements">Elements</a></li>
                <li><a class="guidelines_mainLink" href="/documentation/{$version}/atts">Attributes</a></li>
                <li><a class="guidelines_mainLink" href="/documentation/{$version}/models">Model Classes</a></li>
                <li><a class="guidelines_mainLink" href="/documentation/{$version}/data">Data Types</a></li>
            </ul>
        </div>
    </xsl:template>
    
    <!-- frame for processing each individual item -->
    <xsl:template name="processItems" as="node()*">
        <xsl:param name="items" as="node()*"/>
        <xsl:param name="itemLinks" as="node()*"/>
        <xsl:param name="mode" as="xs:string"/>
        <xsl:if test="not(count($items) = count($itemLinks/descendant-or-self::a))">
            <xsl:message terminate="no" select="'ERROR: The number of items (' || count($items) || ') does not match the number of generated TOC entries (' || count($itemLinks/descendant-or-self::a) || ') for ' || $mode || '. Please check!.'"/>
        </xsl:if>
        
        <xsl:for-each select="$items">
            <xsl:variable name="name" select="if($mode = 'chapters') then(@xml:id) else(@ident)" as="xs:string"/>
            
            <xsl:variable name="result" as="node()">
                <xsl:apply-templates select=".">
                    <xsl:with-param name="target" select="$target" tunnel="yes" as="xs:string"/>
                </xsl:apply-templates>
            </xsl:variable>
            
            <xsl:choose>
                <xsl:when test="$target = 'website'">
                    <xsl:result-document href="{$outPutFolder || $name}.xml">
                        <article class="page type-page status-publish hentry">
                            <div class="entry-content">
                                <div class="panel-grid">
                                    <div class="panel-grid-cell" style="width: 65%; float: left;">
                                        <div class="panel widget widget_text panel-first-child panel-last-child">
                                            <div class="textwidget">
                                                <xsl:sequence select="$result"/>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="panel-grid-cell" style="width: 35%; float: left;">
                                        <div class="panel widget widget_text panel-first-child panel-last-child">
                                            <xsl:call-template name="getPrimarySideNav"/>
                                            <div style="margin: 10px 30px; border-bottom: 0.5px solid #666666; height: 1px;"> </div>
                                            <xsl:choose>
                                                <xsl:when test="$mode = 'chapters'">
                                                    <h3 class="widget-title">Table of Contents</h3>
                                                    <div class="textwidget">
                                                        <ul class="guidelinesList">
                                                            <xsl:for-each select=".//tei:div">
                                                                <xsl:variable name="subChapterID" select="@xml:id"/>
                                                                <xsl:variable name="subChapterTitle" select="./tei:head[1]/text()"/>
                                                                <li><a href="/documentation/{$version}/{$name}#{$subChapterID}"><xsl:value-of select="$subChapterTitle"/></a></li>
                                                            </xsl:for-each>
                                                        </ul>
                                                    </div>
                                                </xsl:when>
                                                <xsl:when test="$mode = ('elements','models','atts','dataMacros')">
                                                    <h3 class="widget-title">
                                                        <xsl:choose>
                                                            <xsl:when test="$mode = 'elements'">MEI Elements</xsl:when>
                                                            <xsl:when test="$mode = 'models'">Model Classes</xsl:when>
                                                            <xsl:when test="$mode = 'atts'">Attribute Classes</xsl:when>
                                                            <xsl:when test="$mode = 'atts'">Data Types and Macros</xsl:when>
                                                        </xsl:choose>
                                                    </h3>
                                                    <div class="textwidget">
                                                        <ul class="guidelinesList">
                                                            <xsl:for-each select="$itemLinks">
                                                                <li><xsl:copy-of select="."/></li>
                                                            </xsl:for-each>
                                                        </ul>
                                                    </div>
                                                </xsl:when>
                                            </xsl:choose>
                                            
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </article>
                    </xsl:result-document>        
                </xsl:when>
                <xsl:when test="$target = 'pdf'">
                    <xsl:sequence select="$result"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:message terminate="yes" select="'ERROR: target medium unspecified.'"/>
                </xsl:otherwise>
            </xsl:choose>
            
            
        </xsl:for-each>
    </xsl:template>
    
    <!-- resolve chapters -->
    <xsl:template match="tei:div[@type = 'div1']">
        <xsl:variable name="chapter" select="." as="node()"/>
        <xsl:variable name="my.index" select="string(count(preceding-sibling::tei:div[@type = 'div1']) + 1)" as="xs:string"/>
        
        <section class="div1">
            <xsl:apply-templates select="node()" mode="#current"/>
        </section>
    </xsl:template>
    
    <xsl:template match="tei:div[not(@type = 'div1')]">
        
        <xsl:variable name="chapter" select="." as="node()"/>
        
        <xsl:if test="not($chapter/@xml:id)">
            <xsl:message terminate="no" select="'ERROR: chapter inside ' || ancestor::tei:div[@xml:id][1]/@xml:id || ' has no @xml:id. Please fix!'"/>
        </xsl:if>
        
        <div>
            <xsl:apply-templates select="node()" mode="#current"/>
        </div>
    </xsl:template>
    
    <xsl:template match="tei:head">
        
        <xsl:choose>
            <xsl:when test="parent::tei:div">
                <xsl:variable name="div.id" select="parent::tei:div/@xml:id" as="xs:string?"/>
                <xsl:choose>
                    <xsl:when test="ancestor::tei:front">
                        <h1>
                            <span class="head"><xsl:value-of select="text()"/></span>
                        </h1>
                    </xsl:when>
                    <xsl:when test="ancestor::tei:back">
                        <xsl:variable name="level" select="string(number(substring-after(parent::tei:div/@type,'div')) + 1)"/>
                        <xsl:element name="h{$level}">
                            <xsl:attribute name="id" select="$div.id"/>
                            <span class="headingNumber"></span>
                            <span class="head"><xsl:value-of select="text()"/></span>
                        </xsl:element>
                    </xsl:when>
                    <xsl:when test="exists($div.id)">
                        <xsl:variable name="tocInfo" select="$all.chapters/*[@xml:id = $div.id]" as="node()*"/>
                        
                        <xsl:if test="not($tocInfo)">
                            <xsl:message terminate="yes" select="'ERROR: Unable to find chapter ' || $div.id || ' in $all.chapters'"/>
                        </xsl:if>
                        
                        <xsl:if test="count($tocInfo) gt 1">
                            <xsl:message terminate="yes" select="'ERROR: Too many chapters with ID ' || $div.id || ' in $all.chapters'"/>
                        </xsl:if>
                        
                        <xsl:element name="h{$tocInfo/@level}">
                            <xsl:attribute name="id" select="$div.id"/>
                            <span class="headingNumber"><xsl:value-of select="$tocInfo/@number"/> </span>
                            <span class="head"><xsl:value-of select="text()"/></span>
                        </xsl:element>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:message select="'WARNING: Heading _' || text() || '_ has no @xml:id, and cannot be referenced therefore. Numbering will be incorrect as well. Please fix!'"/>
                        <h4>
                            <span class="head"><xsl:value-of select="text()"/></span>
                        </h4>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:when test="parent::tei:figure and parent::tei:figure/tei:graphic">
                <figcaption class="caption">Figure <xsl:value-of select="count(preceding::tei:figure[./tei:graphic]) + 1"/>. <xsl:apply-templates select="node()" mode="#current"/></figcaption>
            </xsl:when>
            <xsl:when test="parent::tei:figure and parent::tei:figure/egx:egXML">
                <figcaption class="caption">Listing <xsl:value-of select="count(preceding::tei:figure[./egx:egXML]) + 1"/>. <xsl:apply-templates select="node()" mode="#current"/></figcaption>
            </xsl:when>
            <xsl:when test="parent::tei:figure">
                <xsl:message terminate="no" select="'WARNING: Not rendering tei:head in tei:figure, because there is no apparent element to which it belongs. Content: ' || text()"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:message terminate="no" select="'ERROR: This should not have happened'"/>
            </xsl:otherwise>
        </xsl:choose>
        
    </xsl:template>
    
    <xsl:template match="tei:p">
        <p>
            <xsl:apply-templates select="node()" mode="#current"/>
        </p>
    </xsl:template>
    
    <xsl:template match="tei:list">
        <xsl:choose>
            <xsl:when test="@type = ('bulleted','simple')">
                <xsl:if test="child::tei:head">
                    <strong class="listHead"><xsl:apply-templates select="child::tei:head/node()"/></strong>
                </xsl:if>
                <ul>
                    <xsl:for-each select="tei:item">
                        <li class="item">
                            <xsl:apply-templates select="node()" mode="#current"/>
                        </li>
                    </xsl:for-each>
                </ul>
            </xsl:when>
            <xsl:when test="@type = 'ordered'">
                <xsl:if test="child::tei:head">
                    <strong class="listHead"><xsl:apply-templates select="child::tei:head/node()"/></strong>
                </xsl:if>
                <ol>
                    <xsl:for-each select="tei:item">
                        <li class="item">
                            <xsl:apply-templates select="node()" mode="#current"/>
                        </li>
                    </xsl:for-each>
                </ol>
            </xsl:when>
            <xsl:when test="@type = 'gloss'">
                <dl>
                    <xsl:for-each select="tei:label">
                        <dt><span><xsl:apply-templates select="node()" mode="#current"/></span></dt>
                        <dd><xsl:apply-templates select="following-sibling::tei:item[1]/node()" mode="#current"/></dd>
                    </xsl:for-each>
                </dl>
            </xsl:when>
            <xsl:otherwise>
                <xsl:if test="child::tei:head">
                    <strong class="listHead"><xsl:apply-templates select="child::tei:head/node()"/></strong>
                </xsl:if>
                <ul>
                    <xsl:for-each select="tei:item">
                        <li class="item">
                            <xsl:apply-templates select="node()" mode="#current"/>
                        </li>
                    </xsl:for-each>
                </ul>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    
    <xsl:template match="tei:gi">
        <xsl:variable name="text" select="string(text())" as="xs:string"/>
        <xsl:choose>
            <xsl:when test="$text = $elements/@ident">
                <xsl:choose>
                    <xsl:when test="$target = 'website'">
                        <a class="link_odd_elementSpec" href="/documentation/{$version}/{$text}"><xsl:value-of select="$text"/></a>        
                    </xsl:when>
                    <xsl:when test="$target = 'pdf'">
                        <a class="link_odd_elementSpec" href="#{$text}"><xsl:value-of select="$text"/></a>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:message terminate="yes" select="'ERROR: target medium unspecified.'"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <xsl:message select="'WARNING: Unable to retrieve definition of element ' || $text || '. No link created. Please check spellingâ€¦'"/>
                <xsl:next-match/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    
    <xsl:template match="tei:ident[@type = 'class']">
        <xsl:variable name="text" select="string(text())" as="xs:string"/>
        <xsl:choose>
            <xsl:when test="$text = //tei:classSpec/@ident">
                <xsl:choose>
                    <xsl:when test="$target = 'website'">
                        <a class="link_odd" href="/documentation/{$version}/{$text}"><xsl:value-of select="$text"/></a>        
                    </xsl:when>
                    <xsl:when test="$target = 'pdf'">
                        <a class="link_odd" href="#{$text}"><xsl:value-of select="$text"/></a>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:message terminate="yes" select="'ERROR: target medium unspecified.'"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <xsl:message terminate="no" select="'ERROR: Unable to identify class ' || $text || ' from tei:ident element. No link created.'"/>
                <span class="ident">
                    <xsl:apply-templates select="node()" mode="#current"/>
                </span>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    
    <xsl:template match="tei:specList">
        <ul class="specList">
            <xsl:for-each select="tei:specDesc">
                <xsl:variable name="key" select="@key" as="xs:string"/>
                <xsl:variable name="specDesc" select="." as="node()"/>
                <xsl:variable name="spec" select="if(count(//tei:*[@ident = $key and not(local-name() = ('schemaSpec','valItem'))]) = 1) 
                    then(//tei:*[@ident = $key and not(local-name() = ('schemaSpec','valItem'))]) 
                    else(//tei:*[@ident = $key and not(local-name() = ('schemaSpec','valItem','attDef'))])" as="node()*"/>
                <xsl:if test="count($spec) gt 1">
                    <xsl:message select="'INFO: problem with @ident=' || $key || ', which is found ' || count($spec) || ' times.'"/>
                </xsl:if>
                <xsl:if test="count($spec) = 0">
                    <xsl:message select="'INFO: problem with @ident=' || $key || ', which cannot be found with the current exclusions.'"/>
                </xsl:if>
                <li>
                    <xsl:choose>
                        <xsl:when test="not($specDesc/@atts)">
                            <span class="specList-{local-name($spec)}"><xsl:value-of select="$key"/></span>
                            <xsl:apply-templates select="$spec/tei:desc/node()"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <table class="specDesc">
                                <tbody>
                                    <xsl:for-each select="tokenize(normalize-space($specDesc/@atts),' ')">
                                        <xsl:variable name="current.att" select="." as="xs:string"/>
                                        <tr>
                                            <td class="Attribute">
                                                <span class="att"><xsl:value-of select="$current.att"/></span>
                                            </td>
                                            <td>
                                                <xsl:choose>
                                                    <xsl:when test="$spec//tei:attDef[@ident = $current.att]">
                                                        <xsl:apply-templates select="$spec//tei:attDef[@ident = $current.att]/tei:desc/node()" mode="#current"/>
                                                    </xsl:when>
                                                    <xsl:otherwise>
                                                        <xsl:variable name="attributes" select="local:getAttributes($spec)" as="node()*"/>
                                                        <xsl:apply-templates select="$attributes/descendant-or-self::div[span[@class='attribute']/text() = '@' || $current.att]/span[@class='attributeDesc']/node()" mode="#current"/>
                                                    </xsl:otherwise>
                                                </xsl:choose>
                                            </td>
                                        </tr>
                                    </xsl:for-each>
                                </tbody>
                            </table>
                        </xsl:otherwise>
                    </xsl:choose>
                </li>
            </xsl:for-each>
        </ul>
    </xsl:template>
    
    <!-- This template isn't called from specList, but only for individual specDescs -> should be merged -->
    <xsl:template match="tei:specDesc">
        <div class="specList">
            <xsl:variable name="key" select="@key" as="xs:string"/>
            <xsl:variable name="spec" select="//tei:*[@ident = $key]" as="node()?"/>
            <xsl:if test="not($spec)">
                <xsl:message select="."></xsl:message>
                <xsl:message terminate="yes" select="$key"/>
            </xsl:if>
            <xsl:variable name="specDesc" select="." as="node()"/>
            <xsl:choose>
                <xsl:when test="not($specDesc/@atts)">
                    <span class="specList-{local-name($spec)}"><xsl:value-of select="$key"/></span>
                    <xsl:apply-templates select="$spec/tei:desc/node()"/>
                </xsl:when>
                <xsl:otherwise>
                    <table class="specDesc">
                        <tbody>
                            <xsl:for-each select="tokenize(normalize-space($specDesc/@atts),' ')">
                                <xsl:variable name="current.att" select="." as="xs:string"/>
                                <tr>
                                    <td class="Attribute">
                                        <span class="att"><xsl:value-of select="$current.att"/></span>
                                    </td>
                                    <td>
                                        <xsl:choose>
                                            <xsl:when test="$spec//tei:attDef[@ident = $current.att]">
                                                <xsl:apply-templates select="$spec//tei:attDef[@ident = $current.att]/tei:desc/node()" mode="#current"/>
                                            </xsl:when>
                                            <xsl:otherwise>
                                                <xsl:variable name="attributes" select="local:getAttributes($spec)" as="node()*"/>
                                                <xsl:apply-templates select="$attributes//div[span[@class='attribute']/text() = '@' || $current.att]/span[@class='attributeDesc']/node()" mode="#current"/>
                                            </xsl:otherwise>
                                        </xsl:choose>
                                    </td>
                                </tr>
                            </xsl:for-each>
                        </tbody>
                    </table>
                </xsl:otherwise>
            </xsl:choose>
        </div>
    </xsl:template>
    
    <xsl:template match="tei:ptr">
        
        <xsl:variable name="chapter.id" select="replace(@target,'#','')" as="xs:string"/>
        <xsl:variable name="tocInfo" select="$all.chapters/*[@xml:id = $chapter.id]" as="node()?"/>
        <xsl:choose>
            <xsl:when test="not($tocInfo)">
                <xsl:message terminate="no" select="'ERROR: Could not retrieve chapter with @xml:id ' || $chapter.id || ' (referenced from a //tei:ptr/@target). Please check!'"/>
                <span class="wrong_ptr"> <xsl:value-of select="@target"/> </span>
            </xsl:when>
            <xsl:otherwise>
                
                <xsl:variable name="base.id" select="if($tocInfo/@level = '1') then($tocInfo/@xml:id) else($tocInfo/preceding-sibling::*[@level = '1'][1]/@xml:id)" as="xs:string"/>
                
                <xsl:choose>
                    <xsl:when test="$target = 'website'">
                        <a class="link_ptr" title="{$tocInfo/@head}" href="/documentation/{$version}/{$base.id || (if(not($tocInfo/@level = '1')) then('#' || $chapter.id) else())}"><xsl:value-of select="$tocInfo/@number || ' ' || $tocInfo/@head"/></a>        
                    </xsl:when>
                    <xsl:when test="$target = 'pdf'">
                        <a class="link_ptr" title="{$tocInfo/@head}" href="#{$chapter.id}"><xsl:value-of select="$tocInfo/@number || ' ' || $tocInfo/@head"/></a>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:message terminate="yes" select="'ERROR: target medium unspecified.'"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    
    <xsl:template match="tei:ref">
        <xsl:choose>
            <xsl:when test="starts-with(@target,'#')">
                <xsl:variable name="chapter.id" select="replace(@target,'#','')" as="xs:string"/>
                <xsl:variable name="chapter" select="//tei:div[@xml:id = $chapter.id]" as="node()?"/>
                <xsl:choose>
                    <xsl:when test="exists($chapter)">
                        <xsl:variable name="head" select="string($chapter/tei:head[1]/text())" as="xs:string"/>
                        <xsl:variable name="base.id" select="$chapter/ancestor-or-self::tei:div[@type = 'div1']/@xml:id" as="xs:string"/>
                        
                        <xsl:choose>
                            <xsl:when test="$target = 'website'">                                
                                <a class="link_ref" title="{$head}" href="/documentation/{$version}/{$base.id || (if($base.id = $chapter.id) then() else('#' || $chapter.id))}"><xsl:apply-templates select="node()" mode="#current"/></a>
                            </xsl:when>
                            <xsl:when test="$target = 'pdf'">
                                <a class="link_ref" title="{$head}" href="#{$chapter.id}"><xsl:apply-templates select="node()" mode="#current"/></a>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:message terminate="yes" select="'ERROR: target medium unspecified.'"/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:otherwise>
                        <span class="ref" data-target="{$chapter.id}"><xsl:apply-templates select="node()" mode="#current"/></span>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <a class="link_ref" href="{@target}"><xsl:apply-templates select="node()" mode="#current"/></a>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    
    <xsl:template match="tei:foreign">
        <span class="foreign"><xsl:apply-templates select="node()" mode="#current"/></span>
    </xsl:template>
    
    <xsl:template match="tei:att">
        <span class="att"><xsl:apply-templates select="node()" mode="#current"/></span>
    </xsl:template>
    
    <!-- todo: this should be done with CSS! -->
    <xsl:template match="tei:soCalled">
        <xsl:value-of select="'â€˜'"/><xsl:apply-templates select="node()" mode="#current"/><xsl:value-of select="'â€™'"/>
    </xsl:template>
    
    <xsl:template match="tei:title">
        <span class="titlem"><xsl:apply-templates select="node()" mode="#current"/></span>
    </xsl:template>
    
    <xsl:template match="tei:bibl">
        <span class="bibl"><xsl:apply-templates select="node()" mode="#current"/></span>
    </xsl:template>
    
    <xsl:template match="tei:term">
        <span class="term"><xsl:apply-templates select="node()" mode="#current"/></span>
    </xsl:template>
    
    <xsl:template match="tei:mentioned">
        <span class="mentioned"><xsl:apply-templates select="node()" mode="#current"/></span>
    </xsl:template>
    
    <xsl:template match="tei:emph">
        <em class="mentioned"><xsl:apply-templates select="node()" mode="#current"/></em>
    </xsl:template>
    
    <xsl:template match="tei:exemplum">
        <xsl:apply-templates select="node()" mode="#current"/>
    </xsl:template>
    
    <xsl:template match="egx:egXML">
        <div xml:space="preserve" class="pre egXML_{if(@valid='false') then('invalid') else if(@valid='feasible') then('feasible') else('valid')}">
<xsl:apply-templates select="node()" mode="preserveSpace"/>
        </div>
    </xsl:template>
    
    <xsl:template match="tei:table">
        <xsl:message select="'WARNING: There is still a tei:table, which is probably incorrect. If not, improve this stylesheet.'"/>
        <!--<table>
            
        </table>-->
    </xsl:template>
    
    <!-- todo -->
    <!--<xsl:template match="tei:row">
        
    </xsl:template>
    
    <xsl:template match="tei:cell">
        
    </xsl:template>-->
    
    <xsl:template match="tei:val">
        <span class="val"><xsl:apply-templates select="node()" mode="#current"/></span>
    </xsl:template>
    
    <xsl:template match="tei:formula">
        <span class="formula"><xsl:apply-templates select="node()" mode="#current"/></span>
    </xsl:template>
    
    <xsl:template match="tei:figure">
        <figure class="figure">
            <xsl:apply-templates select="tei:graphic | egx:egXML" mode="#current"/>
            <xsl:apply-templates select="tei:head" mode="#current"/>
        </figure>
    </xsl:template>
    
    <xsl:template match="tei:graphic">
        <img src="{$image.prefix||substring(@url,2)}" class="graphic"/>
    </xsl:template>
    
    <!-- ___________________________ -->
    
    
    <!-- resolve elements -->
    <xsl:template match="tei:elementSpec">
        <xsl:variable name="elementSpec" select="." as="node()"/>
        <div class="elementSpec">
            <h3 id="{@ident}">&lt;<xsl:value-of select="@ident"/>&gt;</h3>
            <table class="wovenodd">
                <tr>
                    <td colspan="2" class="wovenodd-col2">
                        <span class="label">&lt;<xsl:value-of select="@ident"/>&gt;</span>
                        <xsl:value-of select="' '"/><xsl:value-of select="$elementSpec/tei:desc/text()"/>
                    </td>
                </tr>
                <tr>
                    <td class="wovenodd-col1"><span class="label" lang="en">Module</span></td>
                    <td class="wovenodd-col2"><xsl:value-of select="$elementSpec/@module"/></td>
                </tr>
                <tr>
                    <td class="wovenodd-col1"><span class="label" lang="en">Attributes</span></td>
                    <td class="wovenodd-col2">
                        
                        <!-- docu: identify all relevant attributes -->
                        <xsl:variable name="attributes" as="node()*">
                            
                            <!-- docu: get attributes specified at the current element -->
                            <xsl:for-each select="$elementSpec//tei:attDef">
                                <xsl:variable name="current.att" select="." as="node()"/>
                                
                                <xsl:sequence select="local:resolveAttDef($current.att,$elementSpec/@ident)"/>
                                
                            </xsl:for-each>
                            
                            <!-- get attributes derived from attribute classes -->
                            <xsl:sequence select="local:getAttributes($elementSpec)"/>
                        </xsl:variable>
                        <xsl:variable name="attribute.names" select="distinct-values($attributes/descendant-or-self::span[@class = 'attribute']/string(text()))" as="xs:string*"/>
                        
                        <!--<xsl:message select="'DEBUG: element ' || $elementSpec/@ident || ' has ' || count($attribute.names) || ' attributes: ' || string-join($attribute.names,', ')"/>-->
                        
                        <xsl:for-each select="$attribute.names">
                            <xsl:sort select="." data-type="text"/>
                            <xsl:variable name="current.att" select="." as="xs:string"/>
                            <xsl:if test="count($attributes/descendant-or-self::div[span[@class='attribute']/text() = $current.att]) gt 1">
                                <xsl:message select="'INFO: attribute ' || $current.att || ' specified multiple times on element ' || $elementSpec/@ident"/>
                            </xsl:if>
                            <xsl:sequence select="($attributes/descendant-or-self::div[span[@class='attribute']/text() = $current.att])[1]"/>
                        </xsl:for-each>
                        
                    </td>
                </tr>
                <tr>
                    <td class="wovenodd-col1"><span class="label" lang="en">Member of</span></td>
                    <td class="wovenodd-col2">
                        <div class="parent">
                            <xsl:for-each select="$elementSpec//tei:memberOf[starts-with(@key,'model.')]">
                                <xsl:choose>
                                    <xsl:when test="$target = 'website'">
                                        <xsl:value-of select="if(position() gt 1) then(' ') else('')"/><a class="link_odd_classSpec" href="/documentation/{$version}/{@key}"><xsl:value-of select="@key"/></a>        
                                    </xsl:when>
                                    <xsl:when test="$target = 'pdf'">
                                        <xsl:value-of select="if(position() gt 1) then(' ') else('')"/><a class="link_odd_classSpec" href="#{@key}"><xsl:value-of select="@key"/></a>
                                    </xsl:when>
                                    <xsl:otherwise>
                                        <xsl:message terminate="yes" select="'ERROR: target medium is unknown'"/>
                                    </xsl:otherwise>
                                </xsl:choose>
                            </xsl:for-each>
                        </div>
                    </td>
                </tr>
                <tr>
                    <td class="wovenodd-col1"><span class="label" lang="en">Contained by</span></td>
                    <td class="wovenodd-col2">
                        <div class="parent">
                            <div class="specChildren">
                                
                                <xsl:variable name="direct.parents" select="$elements/descendant-or-self::tei:elementSpec[.//tei:content//rng:ref[@name = $elementSpec/@ident]]" as="node()*"/>
                                <xsl:variable name="class.parents" select="local:getParents($model.classes/descendant-or-self::tei:classSpec[@ident = $elementSpec//tei:memberOf[starts-with(@key,'model.')]/@key])" as="node()*"/>
                                <xsl:variable name="macro.parents" select="local:getParents($data.types/descendant-or-self::tei:macroSpec[.//tei:content//rng:ref[@name = $elementSpec/@ident]])" as="node()*"/>
                                
                                <xsl:variable name="parents" select="$direct.parents | $class.parents | $macro.parents" as="node()*"/>
                                <!--<xsl:message select="'INFO: ' || $elementSpec/@ident || ' has ' || count($direct.parents) || ' direct and ' || count($class.parents) ||' class parents.'"/>-->
                                
                                <xsl:for-each select="distinct-values($parents/descendant-or-self::tei:elementSpec/@module)">
                                    <xsl:sort select="count($mei.source//tei:moduleSpec[@ident = current()]/preceding::tei:moduleSpec)" data-type="number"/>
                                    <xsl:variable name="current.module" select="." as="xs:string"/>
                                    <xsl:variable name="relevant.element.names" select="distinct-values($parents/descendant-or-self::tei:elementSpec[@module = $current.module]/@ident)" as="xs:string*"/>
                                    <div class="specChild">
                                        <span class="specChildModule"><xsl:value-of select="$current.module"/></span>
                                        <span class="specChildElements">
                                            <xsl:for-each select="$relevant.element.names">
                                                <xsl:variable name="current.elem" select="." as="xs:string"/>
                                                <xsl:choose>
                                                    <xsl:when test="$target = 'website'">
                                                        <xsl:value-of select="if(position() gt 1) then(' ') else('')"/><a class="link_odd_elementSpec" href="/documentation/{$version}/{$current.elem}"><xsl:value-of select="$current.elem"/></a>        
                                                    </xsl:when>
                                                    <xsl:when test="$target = 'pdf'">
                                                        <xsl:value-of select="if(position() gt 1) then(' ') else('')"/><a class="link_odd_elementSpec" href="#{$current.elem}"><xsl:value-of select="$current.elem"/></a>
                                                    </xsl:when>
                                                    <xsl:otherwise>
                                                        <xsl:message terminate="yes" select="'ERROR: target medium is unknown'"/>
                                                    </xsl:otherwise>
                                                </xsl:choose>
                                            </xsl:for-each>
                                        </span>
                                    </div>
                                </xsl:for-each>
                            </div>
                        </div>
                    </td>
                </tr>
                <tr>
                    <td class="wovenodd-col1"><span class="label" lang="en">May contain</span></td>
                    <td class="wovenodd-col2">
                        <xsl:variable name="direct.childs" select="$elements/descendant-or-self::tei:elementSpec[@ident = $elementSpec//tei:content//rng:ref[not(starts-with(@name,'model.'))]/@name]" as="node()*"/>
                        <xsl:variable name="class.childs" as="node()*">
                            
                            <xsl:for-each select="$elementSpec//tei:content//rng:ref[starts-with(@name,'model.')]">
                                <xsl:variable name="modelClass.name" select="@name" as="xs:string"/>
                                <xsl:sequence select="local:getChilds($modelClass.name)"/>
                            </xsl:for-each>
                        </xsl:variable>
                        <xsl:variable name="macro.childs" as="node()*">
                            <xsl:for-each select="$elementSpec//tei:content//rng:ref[starts-with(@name,'macro.')]">
                                <xsl:variable name="macroSpec.name" select="@name" as="xs:string"/>
                                <xsl:variable name="macroSpec" select="$data.types/descendant-or-self::tei:macroSpec[@ident = $macroSpec.name]" as="node()"/>
                                <xsl:sequence select="$elements/descendant-or-self::tei:elementSpec[@ident = $macroSpec//tei:content//rng:ref/@name]"/>    
                            </xsl:for-each>
                        </xsl:variable>
                        
                        <xsl:variable name="childs" select="$direct.childs | $class.childs | $macro.childs" as="node()*"/>
                        <!--<xsl:message select="'INFO: ' || $elementSpec/@ident || ' has ' || count($direct.childs) || ' direct and ' || count($class.childs) ||' class childs.'"/>-->
                        <xsl:choose>
                            <xsl:when test="(count($childs) gt 0) or $elementSpec//tei:content//rng:text">
                                <div class="specChildren">
                                    <xsl:if test="$elementSpec//tei:content//rng:text">
                                        <div class="specChild">
                                            <span class="specChildModule">Text</span>
                                            <span class="specChildElements"></span>
                                        </div>
                                    </xsl:if>
                                    <xsl:for-each select="distinct-values($childs/descendant-or-self::tei:elementSpec/@module)">
                                        <xsl:sort select="count($mei.source//tei:moduleSpec[@ident = current()]/preceding::tei:moduleSpec)" data-type="number"/>
                                        <xsl:variable name="current.module" select="." as="xs:string"/>
                                        <xsl:variable name="relevant.element.names" select="distinct-values($childs/descendant-or-self::tei:elementSpec[@module = $current.module]/@ident)" as="xs:string*"/>
                                        <div class="specChild">
                                            <span class="specChildModule"><xsl:value-of select="$current.module"/></span>
                                            <span class="specChildElements">
                                                <xsl:for-each select="$relevant.element.names">
                                                    <xsl:variable name="current.elem" select="." as="xs:string"/>
                                                    <xsl:choose>
                                                        <xsl:when test="$target = 'website'">
                                                            <xsl:value-of select="if(position() gt 1) then(' ') else('')"/><a class="link_odd_elementSpec" href="/documentation/{$version}/{$current.elem}"><xsl:value-of select="$current.elem"/></a>        
                                                        </xsl:when>
                                                        <xsl:when test="$target = 'pdf'">
                                                            <xsl:value-of select="if(position() gt 1) then(' ') else('')"/><a class="link_odd_elementSpec" href="#{$current.elem}"><xsl:value-of select="$current.elem"/></a>
                                                        </xsl:when>
                                                        <xsl:otherwise>
                                                            <xsl:message terminate="yes" select="'ERROR: target medium is unknown'"/>
                                                        </xsl:otherwise>
                                                    </xsl:choose>                                                    
                                                </xsl:for-each>
                                            </span>
                                        </div>
                                    </xsl:for-each>
                                </div>
                            </xsl:when>
                            <xsl:otherwise>
                                <div class="specChild">
                                    <span class="specChildModule">Empty</span>
                                    <span class="specChildElements"></span>
                                </div> 
                            </xsl:otherwise>
                        </xsl:choose>
                    </td>
                </tr>
                <tr>
                    <td class="wovenodd-col1"><span class="label" lang="en">Declaration</span></td>
                    <td class="wovenodd-col2">
                        <div xml:space="preserve" class="pre"><xsl:apply-templates select="$elementSpec/(tei:classes | tei:content)" mode="preserveSpace"><xsl:with-param name="getODD" tunnel="yes" select="true()"/></xsl:apply-templates></div>
                    </td>
                </tr>
                <xsl:if test="$elementSpec/tei:exemplum">
                    <tr>
                        <td class="wovenodd-col1"><span class="label" lang="en">Examples</span></td>
                        <td class="wovenodd-col2">
                            <xsl:for-each select="$elementSpec/tei:exemplum">
                                <div xml:space="preserve" class="pre"><xsl:apply-templates select="child::egx:egXML/child::*" mode="preserveSpace"><xsl:with-param name="getODD" tunnel="yes" select="true()"/></xsl:apply-templates></div>
                            </xsl:for-each>
                        </td>
                    </tr>
                </xsl:if>
                <xsl:if test="$elementSpec/tei:remarks">
                    <tr>
                        <td class="wovenodd-col1"><span class="label" lang="en">Remarks</span></td>
                        <td class="wovenodd-col2">
                            <p><xsl:apply-templates select="$elementSpec/tei:remarks/tei:p/node()"/></p>
                        </td>
                    </tr>
                </xsl:if>
                <xsl:for-each select="$elementSpec//tei:constraintSpec">
                    <tr>
                        <td class="wovenodd-col1"><span class="label" lang="en">Constraints</span></td>
                        <td class="wovenodd-col2">
                            <div>
                                <xsl:for-each select=".//sch:assert">
                                    <!--<xsl:if test="count(.//text()) gt 1">
                                        <xsl:message select="." terminate="yes"></xsl:message>
                                    </xsl:if>-->
                                    <div><xsl:value-of select="normalize-space(string-join(.//text(),' '))"/></div>
                                </xsl:for-each>
                            </div>
                            <div xml:space="preserve" class="pre"><xsl:apply-templates select=".//sch:rule" mode="preserveSpace"/></div>
                        </td>
                    </tr>
                </xsl:for-each>
            </table>
        </div>
    </xsl:template>
    
    <xsl:function name="local:getAttributes" as="node()*">
        <xsl:param name="elem" as="node()"/>
        
        <xsl:variable name="classes" select="$elem//tei:memberOf[starts-with(@key,'att.')]/@key" as="xs:string*"/>
        
        <xsl:for-each select="$classes">
            <xsl:variable name="current.class.id" select="." as="xs:string"/>
            <xsl:variable name="current.class" select="$mei.source//tei:classSpec[@ident = $current.class.id]" as="node()"/>
            
            <xsl:for-each select="$current.class//tei:attDef">
                <xsl:variable name="current.att" select="." as="node()"/>
                
                <xsl:sequence select="local:resolveAttDef($current.att,$current.class.id)"/>
            </xsl:for-each>
            
            <xsl:sequence select="local:getAttributes($current.class)"/>
            
        </xsl:for-each>
        
    </xsl:function>
    
    <xsl:function name="local:resolveAttDef" as="node()">
        <xsl:param name="current.att" as="node()"/>
        <xsl:param name="current.class.id" as="xs:string?"/>
        
        <div class="attributeDef">
            <span class="attribute">@<xsl:value-of select="$current.att/@ident"/></span>
            <span class="attributeUsage">(<xsl:value-of select="if($current.att/@usage = 'opt') then('optional') else if($current.att/@usage = 'req') then('required') else($current.att/@usage)"/>)</span>
            <span class="attributeDesc"><xsl:apply-templates select="$current.att/tei:desc/node()"/></span>
            <xsl:choose>
                <xsl:when test="$current.att/tei:valList">
                    Allowed values are:
                    <xsl:for-each select="$current.att/tei:valList/tei:valItem">
                        <xsl:if test="position() gt 1">, </xsl:if> "<span style="font-weight: 500;"><xsl:value-of select="@ident"/></span>" <xsl:if test="tei:desc"> <i>(<xsl:value-of select="tei:desc/text()"/>)</i></xsl:if>
                    </xsl:for-each>
                    <xsl:if test="$current.att/tei:valList/@type = 'semi' and $current.att/tei:dataType/rng:data[@type = 'NMTOKEN']">
                        and custom <i>NMToken</i>
                    </xsl:if>
                </xsl:when>
                <xsl:when test="$current.att/tei:datatype[rng:ref]">
                    <xsl:variable name="dt" select="$current.att/tei:datatype" as="node()"/>
                    <xsl:choose>
                        <xsl:when test="$dt/@maxOccurs = '1'">
                            Value conforms to 
                            <xsl:choose>
                                <xsl:when test="$target = 'website'">
                                    <a class="link_odd_classSpec" href="/documentation/{$version}/{$dt/rng:ref/@name}"><xsl:value-of select="$dt/rng:ref/@name"/></a>   
                                </xsl:when>
                                <xsl:when test="$target = 'pdf'">
                                    <a class="link_odd_classSpec" href="#{$dt/rng:ref/@name}"><xsl:value-of select="$dt/rng:ref/@name"/></a>                 
                                </xsl:when>
                            </xsl:choose>
                            .
                        </xsl:when>
                        <xsl:when test="$dt/@maxOccurs = '2'">
                            One or two values from 
                            <xsl:choose>
                                <xsl:when test="$target = 'website'">
                                    <a class="link_odd_classSpec" href="/documentation/{$version}/{$dt/rng:ref/@name}"><xsl:value-of select="$dt/rng:ref/@name"/></a>   
                                </xsl:when>
                                <xsl:when test="$target = 'pdf'">
                                    <a class="link_odd_classSpec" href="#{$dt/rng:ref/@name}"><xsl:value-of select="$dt/rng:ref/@name"/></a>                 
                                </xsl:when>
                            </xsl:choose>
                            , separated by a space.
                        </xsl:when>
                        <xsl:when test="$dt/@maxOccurs = 'unbounded'">
                            One or more values from 
                            <xsl:choose>
                                <xsl:when test="$target = 'website'">
                                    <a class="link_odd_classSpec" href="/documentation/{$version}/{$dt/rng:ref/@name}"><xsl:value-of select="$dt/rng:ref/@name"/></a>   
                                </xsl:when>
                                <xsl:when test="$target = 'pdf'">
                                    <a class="link_odd_classSpec" href="#{$dt/rng:ref/@name}"><xsl:value-of select="$dt/rng:ref/@name"/></a>                 
                                </xsl:when>
                            </xsl:choose>
                            , separated by spaces.
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:message select="'ERROR: Unable to resolve the following datatype on attribute ' || $current.att/@ident"/>
                            <xsl:message terminate="yes" select="$dt"/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:when test="$current.att/tei:datatype[rng:data]">
                    <xsl:variable name="dt" select="$current.att/tei:datatype" as="node()"/>
                    <xsl:choose>
                        <xsl:when test="$dt/@maxOccurs = '1'">
                            Value of datatype <span style="font-weight: 500;"><xsl:sequence select="local:resolveData($dt//rng:data[1])"/></span>.
                        </xsl:when>
                        <xsl:when test="$dt/@maxOccurs = '2'">
                            One or two values of datatype <span style="font-weight: 500;"><xsl:sequence select="local:resolveData($dt//rng:data[1])"/></span>, separated by a space.
                        </xsl:when>
                        <xsl:when test="$dt/@maxOccurs = 'unbounded'">
                            One or more values of datatype <span style="font-weight: 500;"><xsl:sequence select="local:resolveData($dt//rng:data[1])"/></span>, separated by spaces.
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:message select="'ERROR: Unable to resolve the following datatype on attribute ' || $current.att/@ident"/>
                            <xsl:message terminate="yes" select="$dt"/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:when test="$current.att/tei:datatype[rng:list]">
                    <xsl:variable name="dt" select="$current.att/tei:datatype" as="node()"/>
                    <xsl:choose>
                        <xsl:when test="$dt/rng:list/rng:oneOrMore/rng:data[@type='token']/rng:param[@name='pattern']">
                            One or more values conforming to the pattern "<span style="font-weight: 500;"><xsl:value-of select="$dt//rng:param[@name='pattern']/text()"/></span>".
                        </xsl:when>
                        <xsl:when test="count($dt/rng:list/rng:oneOrMore/rng:data) = 2">
                            One or more values, each consisting of a sequence of <span style="font-weight: 500;"><xsl:sequence select="local:resolveData($dt//rng:data[1])"/></span> and <span style="font-weight: 500;"><xsl:sequence select="local:resolveData($dt//rng:data[2])"/></span> sub-values.
                        </xsl:when>
                        <xsl:when test="count($dt/rng:list/rng:oneOrMore/rng:data) = 1">
                            One or more of <span style="font-weight: 500;"><xsl:sequence select="local:resolveData($dt//rng:data[1])"/></span>.
                        </xsl:when>
                        <xsl:when test="$dt/rng:list/rng:oneOrMore/rng:data[following-sibling::rng:ref]">
                            One or more values, each consisting of a sequence of a <span style="font-weight: 500;"><xsl:sequence select="local:resolveData($dt//rng:data)"/></span> part, followed by a <xsl:choose>
                                <xsl:when test="$target = 'website'">
                                    <a class="link_odd_classSpec" href="/documentation/{$version}/{$dt//rng:ref/@name}"><xsl:value-of select="$dt//rng:ref/@name"/></a>   
                                </xsl:when>
                                <xsl:when test="$target = 'pdf'">
                                    <a class="link_odd_classSpec" href="#{$dt//rng:ref/@name}"><xsl:value-of select="$dt//rng:ref/@name"/></a>                 
                                </xsl:when>
                            </xsl:choose>.
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:message select="'ERROR: Unable to resolve the following datatype on attribute ' || $current.att/@ident"/>
                            <xsl:message terminate="yes" select="$dt"/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:when test="$current.att/tei:datatype[rng:choice]">
                    <xsl:variable name="dt" select="$current.att/tei:datatype" as="node()"/>
                    <xsl:choose>
                        <xsl:when test="$dt/rng:choice[count(child::rng:data) = 2]">
                            Value must either conform to <span style="font-weight: 500;"><xsl:sequence select="local:resolveData($dt//rng:data[1])"/></span> or <span style="font-weight: 500;"><xsl:sequence select="local:resolveData($dt//rng:data[2])"/></span>.                            
                        </xsl:when>
                        <xsl:when test="$dt/rng:choice[count(child::*) = 1]">
                            Value must conform to <span style="font-weight: 500;"><xsl:sequence select="local:resolveData($dt//rng:data[1])"/></span>.                            
                        </xsl:when>
                        <xsl:when test="$dt/rng:choice[count(child::*) = 2 and rng:ref[@name = 'data.BOOLEAN'] and rng:value]">
                            Value must be either <span style="font-weight: 500;"><xsl:sequence select="local:resolveData($dt//rng:ref)"/></span> or the value <span style="font-weight: 500;"><xsl:sequence select="$dt//rng:value/text()"/></span>.                            
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:message select="'ERROR: Unable to resolve the following datatype on attribute ' || $current.att/@ident"/>
                            <xsl:message terminate="yes" select="$dt"/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:when test="$current.att/tei:datatype[rng:text]">
                    <xsl:variable name="dt" select="$current.att/tei:datatype" as="node()"/>
                    <xsl:choose>
                        <xsl:when test="count($dt/child::*) = 1 and $dt/rng:text and $dt/@maxOccurs = '1'">
                            Value is plain text.
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:message select="'ERROR: Unable to resolve the following datatype on attribute ' || $current.att/@ident"/>
                            <xsl:message terminate="yes" select="$dt"/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:message select="'WARNING: Not sure how to resolve the values of attDef ' || $current.att/@ident"/>
                </xsl:otherwise>
            </xsl:choose>
            <span class="attributeClasses">
                <xsl:choose>
                    <xsl:when test="$target = 'website'">
                        <a class="link_odd" href="/documentation/{$version}/{$current.class.id}"><xsl:value-of select="$current.class.id"/></a>
                    </xsl:when>
                    <xsl:when test="$target = 'pdf'">
                        <a class="link_odd" href="#{$current.class.id}"><xsl:value-of select="$current.class.id"/></a>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:message terminate="yes" select="'ERROR: unable to identify target medium.'"/>
                    </xsl:otherwise>
                </xsl:choose>                        
            </span>
        </div>
        
    </xsl:function>
    
    <xsl:function name="local:resolveData" as="node()+">
        <xsl:param name="data" as="node()"/>
        
        <xsl:choose>
            <xsl:when test="not($data/child::*)">
                <xsl:value-of select="$data/@type"/>
            </xsl:when>
            <xsl:when test="$data/@type = ('string','token') and $data/rng:param[@name = 'pattern']">
                a string matching the following regular expression: "<xsl:value-of select="$data/rng:param/text()"/>"
            </xsl:when>
            <xsl:when test="$data/@type = 'decimal' and $data/rng:param[@name = 'minInclusive'] and $data/rng:param[@name = 'maxInclusive']">
                a decimal number between <xsl:value-of select="$data/rng:param[@name = 'minInclusive']/text()"/> and <xsl:value-of select="$data/rng:param[@name = 'maxInclusive']/text()"/>
            </xsl:when>
            <xsl:when test="$data/@type = 'decimal' and $data/rng:param[@name = 'minExclusive']">
                a decimal number larger than <xsl:value-of select="$data/rng:param/text()"/>
            </xsl:when>
            <xsl:when test="$data/@type = 'positiveInteger' and $data/rng:param[@name = 'minInclusive'] and $data/rng:param[@name = 'maxInclusive']">
                a positive integer between <xsl:value-of select="$data/rng:param[@name = 'minInclusive']/text()"/> and <xsl:value-of select="$data/rng:param[@name = 'maxInclusive']/text()"/>
            </xsl:when>
            <xsl:when test="$data/@type = 'positiveInteger' and $data/rng:param[@name = 'maxInclusive']">
                a positive integer no larger than <xsl:value-of select="$data/rng:param/text()"/>
            </xsl:when>
            <xsl:when test="$data/@type = 'positiveInteger' and $data/rng:param[@name = 'minInclusive']">
                a positive integer larger than or equal to <xsl:value-of select="$data/rng:param/text()"/>
            </xsl:when>
            <xsl:when test="$data/@type = 'nonNegativeInteger' and $data/rng:param[@name = 'maxInclusive']">
                a non-negative integer no larger than <xsl:value-of select="$data/rng:param/text()"/>
            </xsl:when>
            <xsl:when test="$data/@type = 'decimal' and $data/rng:param[@name = 'minInclusive']">
                a decimal number no smaller than <xsl:value-of select="$data/rng:param/text()"/>
            </xsl:when>
            <xsl:when test="$data/@type = 'positiveInteger' and $data/rng:param[@name = 'pattern']">
                one of the following integers: <xsl:value-of select="string-join(tokenize($data/rng:param/text(),'|'),', ')"/>
            </xsl:when>
            <xsl:when test="$data/@type = 'decimal' and $data/rng:param[@name = 'pattern']">
                a decimal number matching the pattern "<xsl:value-of select="$data/rng:param/text()"/>"
            </xsl:when>
            <xsl:otherwise>
                <xsl:message select="'ERROR: Cannot resolve the following datatype:'"/>
                <xsl:message terminate="yes" select="$data"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>
    
    <xsl:function name="local:getParents" as="node()*">
        <xsl:param name="model.classes" as="node()*"/>
        
        <xsl:for-each select="$model.classes">
            <xsl:variable name="current.model" select="." as="node()"/>
            <xsl:variable name="relevant.elements" select="$mei.source//tei:elementSpec[.//tei:memberOf[@key = $current.model/@ident] or .//tei:content//rng:ref[@name = $current.model/@ident]]" as="node()*"/>
            <!--<xsl:message select="'  INFO: looking for ' || count($relevant.elements) || ' elements in ' || $current.model/@ident"/>-->
            <xsl:sequence select="$relevant.elements"/>
            <xsl:variable name="inheriting.classes" select="$mei.source//tei:classSpec[@type = 'model' and @ident = $current.model//tei:memberOf/@key]" as="node()*"/>
            <xsl:sequence select="local:getParents($inheriting.classes)"/>
        </xsl:for-each>
    </xsl:function>
    
    <xsl:function name="local:getChilds" as="node()*">
        <xsl:param name="className" as="xs:string"/>
        <xsl:sequence select="$elements/descendant-or-self::tei:elementSpec[.//tei:memberOf[@key = $className]]"/>
        
        <xsl:variable name="inheriting.models" select="$model.classes/descendant-or-self::tei:classSpec[.//tei:memberOf/@key = $className]/@ident" as="xs:string*"/>
        <xsl:for-each select="$inheriting.models">
            <xsl:sequence select="local:getChilds(.)"/>    
        </xsl:for-each>
        
    </xsl:function>
    
    <!-- resolve model classes -->
    <xsl:template match="tei:classSpec[@type = 'model']">
        
        <xsl:variable name="classSpec" select="." as="node()"/>
        <div class="classSpec model">
            <h3 id="{@ident}"><xsl:value-of select="@ident"/></h3>
            <table class="wovenodd">
                <tr>
                    <td colspan="2" class="wovenodd-col2">
                        <span class="label"><xsl:value-of select="@ident"/> </span>
                        <xsl:value-of select="' '"/><xsl:value-of select="$classSpec/tei:desc/text()"/>
                    </td>
                </tr>
                <tr>
                    <td class="wovenodd-col1"><span class="label" lang="en">Module</span></td>
                    <td class="wovenodd-col2"><xsl:value-of select="$classSpec/@module"/></td>
                </tr>
                <tr>
                    <td class="wovenodd-col1"><span class="label" lang="en">Available in</span></td>
                    <td class="wovenodd-col2">
                        <div class="parent">
                            <xsl:variable name="direct.members" select="$classSpec/tei:classes/tei:memberOf[starts-with(@key,'model.')]" as="node()*"/>
                            <xsl:if test="count($direct.members) gt 0">
                                <div>
                                    <xsl:for-each select="$direct.members">
                                        <xsl:choose>
                                            <xsl:when test="$target = 'website'">
                                                <xsl:value-of select="if(position() gt 1) then(', ') else('')"/><a class="link_odd_classSpec" href="/documentation/{$version}/{@key}"><xsl:value-of select="@key"/></a>
                                            </xsl:when>
                                            <xsl:when test="$target = 'pdf'">
                                                <xsl:value-of select="if(position() gt 1) then(', ') else('')"/><a class="link_odd_classSpec" href="#{@key}"><xsl:value-of select="@key"/></a>
                                            </xsl:when>
                                            <xsl:otherwise>
                                                <xsl:message terminate="yes" select="'ERROR: target medium not specified.'"/>
                                            </xsl:otherwise>
                                        </xsl:choose>
                                    </xsl:for-each>
                                </div>
                            </xsl:if>
                            <xsl:variable name="referenced.members" select="$mei.source//tei:elementSpec[tei:content//rng:ref/@name = $classSpec/@ident]" as="node()*"/>
                            <xsl:if test="count($referenced.members) gt 0">
                                <div>
                                    <xsl:for-each select="$referenced.members">
                                        <xsl:choose>
                                            <xsl:when test="$target = 'website'">
                                                <xsl:value-of select="if(position() gt 1) then(', ') else('')"/><a class="link_odd_elementSpec" href="/documentation/{$version}/{@ident}"><xsl:value-of select="@ident"/></a>                                                
                                            </xsl:when>
                                            <xsl:when test="$target = 'pdf'">
                                                <xsl:value-of select="if(position() gt 1) then(', ') else('')"/><a class="link_odd_elementSpec" href="#{@ident}"><xsl:value-of select="@ident"/></a>
                                            </xsl:when>
                                            <xsl:otherwise>
                                                <xsl:message terminate="yes" select="'ERROR: target medium not specified.'"/>
                                            </xsl:otherwise>
                                        </xsl:choose>
                                    </xsl:for-each>
                                </div>
                            </xsl:if>
                        </div>
                    </td>
                </tr>
                <tr>
                    <td class="wovenodd-col1"><span class="label" lang="en">Members</span></td>
                    <td class="wovenodd-col2">
                        <div class="parent">
                            <xsl:variable name="direct.members" select="$mei.source//tei:elementSpec[.//tei:memberOf[@key = $classSpec/@ident]]" as="node()*"/>
                            <xsl:if test="count($direct.members) gt 0">
                                <div>
                                    <xsl:for-each select="$direct.members">
                                        <xsl:choose>
                                            <xsl:when test="$target = 'website'">
                                                <xsl:value-of select="if(position() gt 1) then(', ') else('')"/><a class="link_odd_elementSpec" href="/documentation/{$version}/{@ident}"><xsl:value-of select="@ident"/></a>                                                
                                            </xsl:when>
                                            <xsl:when test="$target = 'pdf'">
                                                <xsl:value-of select="if(position() gt 1) then(', ') else('')"/><a class="link_odd_elementSpec" href="#{@ident}"><xsl:value-of select="@ident"/></a>                                                
                                            </xsl:when>
                                            <xsl:otherwise>
                                                <xsl:message terminate="yes" select="'ERROR: target medium not specified.'"/>
                                            </xsl:otherwise>
                                        </xsl:choose>
                                    </xsl:for-each>
                                    <xsl:choose>
                                        <xsl:when test="count($direct.members) = 0"/>
                                        <xsl:when test="count($direct.members) = 1">
                                            <xsl:value-of select="' (direct member of ' || $classSpec/@ident || ')'"/>
                                        </xsl:when>
                                        <xsl:otherwise>
                                            <xsl:value-of select="' (direct members of ' || $classSpec/@ident || ')'"/>
                                        </xsl:otherwise>
                                    </xsl:choose>
                                </div>
                            </xsl:if>
                            <xsl:for-each select="local:getElementsByModelClass($classSpec/@ident)">
                                <xsl:sequence select="."/>
                            </xsl:for-each>
                        </div>
                    </td>
                </tr>
                <xsl:if test="$classSpec/tei:classes">
                    <tr>
                        <td class="wovenodd-col1"><span class="label" lang="en">Declaration</span></td>
                        <td class="wovenodd-col2">
                            <div xml:space="preserve" class="pre"><xsl:apply-templates select="$classSpec/tei:classes" mode="preserveSpace"><xsl:with-param name="getODD" tunnel="yes" select="true()"/></xsl:apply-templates></div>
                        </td>
                    </tr>
                </xsl:if>
                <xsl:if test="$classSpec/tei:remarks">
                    <tr>
                        <td class="wovenodd-col1"><span class="label" lang="en">Remarks</span></td>
                        <td class="wovenodd-col2">
                            <p><xsl:apply-templates select="$classSpec/tei:remarks/tei:p/node()"/></p>
                        </td>
                    </tr>
                </xsl:if>
                <xsl:for-each select="$classSpec//tei:constraintSpec">
                    <tr>
                        <td class="wovenodd-col1"><span class="label" lang="en">Constraints</span></td>
                        <td class="wovenodd-col2">
                            <div>
                                <xsl:for-each select=".//sch:assert">
                                    <div><xsl:value-of select="normalize-space(.//text())"/></div>
                                </xsl:for-each>
                            </div>
                            <div xml:space="preserve" class="pre"><xsl:apply-templates select=".//sch:rule" mode="preserveSpace"/></div>
                        </td>
                    </tr>
                </xsl:for-each>
            </table>
        </div>
    </xsl:template>
    
    <!-- resolve attribute classes -->
    <xsl:template match="tei:classSpec[@type = 'atts']">
        
        <xsl:variable name="classSpec" select="." as="node()"/>
        <div class="classSpec att">
            <h3 id="{@ident}"><xsl:value-of select="@ident"/></h3>
            <table class="wovenodd">
                <tr>
                    <td colspan="2" class="wovenodd-col2">
                        <span class="label"><xsl:value-of select="@ident"/> </span>
                        <xsl:value-of select="' '"/><xsl:value-of select="$classSpec/tei:desc/text()"/>
                    </td>
                </tr>
                <tr>
                    <td class="wovenodd-col1"><span class="label" lang="en">Module</span></td>
                    <td class="wovenodd-col2"><xsl:value-of select="$classSpec/@module"/></td>
                </tr>
                <tr>
                    <td class="wovenodd-col1"><span class="label" lang="en">Members</span></td>
                    <td class="wovenodd-col2">
                        <div class="parent">
                            <xsl:variable name="direct.members" select="$mei.source//tei:elementSpec[.//tei:memberOf[@key = $classSpec/@ident]]" as="node()*"/>
                            <xsl:if test="count($direct.members) gt 0">
                                <div>
                                    <xsl:for-each select="$direct.members">
                                        <xsl:choose>
                                            <xsl:when test="$target = 'website'">
                                                <xsl:value-of select="if(position() gt 1) then(', ') else('')"/><a class="link_odd_elementSpec" href="/documentation/{$version}/{@ident}"><xsl:value-of select="@ident"/></a>                                                
                                            </xsl:when>
                                            <xsl:when test="$target = 'pdf'">
                                                <xsl:value-of select="if(position() gt 1) then(', ') else('')"/><a class="link_odd_elementSpec" href="#{@ident}"><xsl:value-of select="@ident"/></a>                                      
                                            </xsl:when>
                                            <xsl:otherwise>
                                                <xsl:message terminate="yes" select="'ERROR: target medium not specified.'"/>
                                            </xsl:otherwise>
                                        </xsl:choose>
                                    </xsl:for-each>
                                    <xsl:choose>
                                        <xsl:when test="count($direct.members) = 0"/>
                                        <xsl:when test="count($direct.members) = 1">
                                            <xsl:value-of select="' (direct member of ' || $classSpec/@ident || ')'"/>
                                        </xsl:when>
                                        <xsl:otherwise>
                                            <xsl:value-of select="' (direct members of ' || $classSpec/@ident || ')'"/>
                                        </xsl:otherwise>
                                    </xsl:choose>
                                </div>
                            </xsl:if>
                            <xsl:for-each select="local:getElementsByAttClass($classSpec/@ident)">
                                <xsl:sequence select="."/>
                            </xsl:for-each>
                        </div>
                    </td>
                </tr>
                <tr>
                    <td class="wovenodd-col1"><span class="label" lang="en">Attributes</span></td>
                    <td class="wovenodd-col2">
                        
                        <!-- docu: identify all relevant attributes -->
                        <xsl:variable name="attributes" as="node()*">
                            
                            <!-- docu: get attributes specified at the current element -->
                            <xsl:for-each select="$classSpec//tei:attDef">
                                <xsl:variable name="current.att" select="." as="node()"/>
                                
                                <xsl:sequence select="local:resolveAttDef($current.att,$classSpec/@ident)"/>
                            </xsl:for-each>
                            <!-- get attributes derived from attribute classes -->
                            <xsl:sequence select="local:getAttributes($classSpec)"/>
                        </xsl:variable>
                        <xsl:variable name="attribute.names" select="distinct-values($attributes/descendant-or-self::span[@class = 'attribute']/string(text()))" as="xs:string*"/>
                        
                        <xsl:for-each select="$attribute.names">
                            <xsl:sort select="." data-type="text"/>
                            <xsl:variable name="current.att" select="." as="xs:string"/>
                            <xsl:if test="count($attributes/descendant-or-self::div[span[@class='attribute']/text() = $current.att]) gt 1">
                                <xsl:message select="'INFO: attribute ' || $current.att || ' specified multiple times on class ' || $classSpec/@ident"/>
                            </xsl:if>
                            <xsl:sequence select="($attributes/descendant-or-self::div[span[@class='attribute']/text() = $current.att])[1]"/>
                        </xsl:for-each>
                        
                    </td>
                </tr>
                <xsl:if test="$classSpec/tei:classes or $classSpec//tei:attDef">
                    <tr>
                        <td class="wovenodd-col1"><span class="label" lang="en">Declaration</span></td>
                        <td class="wovenodd-col2">
                            <xsl:if test="$classSpec/tei:classes">
                                <div xml:space="preserve" class="pre"><xsl:apply-templates select="$classSpec/tei:classes" mode="preserveSpace"><xsl:with-param name="getODD" tunnel="yes" select="true()"/></xsl:apply-templates></div>    
                            </xsl:if>
                            <xsl:for-each select="$classSpec//tei:attDef">
                                <div xml:space="preserve" class="pre"><xsl:apply-templates select="." mode="preserveSpace"><xsl:with-param name="getODD" tunnel="yes" select="true()"/></xsl:apply-templates></div>
                            </xsl:for-each>
                        </td>
                    </tr>
                </xsl:if>
                <xsl:if test="$classSpec/tei:remarks">
                    <tr>
                        <td class="wovenodd-col1"><span class="label" lang="en">Remarks</span></td>
                        <td class="wovenodd-col2">
                            <p><xsl:apply-templates select="$classSpec/tei:remarks/tei:p/node()"/></p>
                        </td>
                    </tr>
                </xsl:if>
                <xsl:for-each select="$classSpec//tei:constraintSpec">
                    <tr>
                        <td class="wovenodd-col1"><span class="label" lang="en">Constraints</span></td>
                        <td class="wovenodd-col2">
                            <div>
                                <xsl:for-each select=".//sch:assert">
                                    <div><xsl:value-of select="normalize-space(string-join(.//text(),' '))"/></div>
                                </xsl:for-each>
                            </div>
                            <div xml:space="preserve" class="pre"><xsl:apply-templates select=".//sch:rule" mode="preserveSpace"/></div>
                        </td>
                    </tr>
                </xsl:for-each>
            </table>
        </div>
    </xsl:template>
    
    <xsl:function name="local:getElementsByAttClass" as="node()*">
        <xsl:param name="att.class" as="xs:string"/>
                
        <xsl:variable name="inheriting.classes" select="$mei.source//tei:classSpec[@type = 'atts'][.//tei:memberOf/@key = $att.class]" as="node()*"/>
        <xsl:for-each select="$inheriting.classes">
            <xsl:variable name="current.class" select="." as="node()"/>
            <xsl:variable name="relevant.elements" select="$mei.source//tei:elementSpec[.//tei:memberOf[@key = $current.class/@ident] or .//tei:content//rng:ref[@name = $current.class/@ident]]" as="node()*"/>
            
            <xsl:choose>
                <xsl:when test="count($relevant.elements) gt 0">
                    <div>
                        <xsl:for-each select="$relevant.elements">
                            <xsl:choose>
                                <xsl:when test="$target = 'website'">
                                    <xsl:value-of select="if(position() gt 1) then(', ') else('')"/><a class="link_odd_elementSpec" href="/documentation/{$version}/{@ident}"><xsl:value-of select="@ident"/></a>                                    
                                </xsl:when>
                                <xsl:when test="$target = 'pdf'">
                                    <xsl:value-of select="if(position() gt 1) then(', ') else('')"/><a class="link_odd_elementSpec" href="#{@ident}"><xsl:value-of select="@ident"/></a>                 
                                </xsl:when>
                                <xsl:otherwise>
                                    <xsl:message terminate="yes" select="'ERROR: cannot identify target medium'"/>
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:for-each>
                        <xsl:choose>
                            <xsl:when test="$target = 'website'">
                                <span> (via <a class="link_odd_classSpec" href="/documentation/{$version}/{$current.class/@ident}"><xsl:value-of select="$current.class/@ident"/></a>)</span>
                            </xsl:when>
                            <xsl:when test="$target = 'pdf'">
                                <span> (via <a class="link_odd_classSpec" href="#{$current.class/@ident}"><xsl:value-of select="$current.class/@ident"/></a>)</span>
                            </xsl:when>
                        </xsl:choose>
                    </div>
                </xsl:when>
                <xsl:otherwise>
                    <div>
                        <xsl:choose>
                            <xsl:when test="$target = 'website'">
                                <span><a class="link_odd_classSpec" href="/documentation/{$version}/{$current.class/@ident}"><xsl:value-of select="$current.class/@ident"/></a> (no elements directly inheriting from this class)</span>
                            </xsl:when>
                            <xsl:when test="$target = 'pdf'">
                                <span><a class="link_odd_classSpec" href="#{$current.class/@ident}"><xsl:value-of select="$current.class/@ident"/></a> (no elements directly inheriting from this class)</span>
                            </xsl:when>
                        </xsl:choose>
                    </div>
                </xsl:otherwise>
            </xsl:choose>
            
            <xsl:sequence select="local:getElementsByAttClass($current.class/@ident)"/>
        </xsl:for-each>
    </xsl:function>
    
    <xsl:function name="local:getElementsByModelClass" as="node()*">
        <xsl:param name="att.class" as="xs:string"/>
        
        <xsl:variable name="inheriting.classes" select="$mei.source//tei:classSpec[@type = 'model'][.//tei:memberOf/@key = $att.class]" as="node()*"/>
        <xsl:for-each select="$inheriting.classes">
            <xsl:variable name="current.class" select="." as="node()"/>
            <xsl:variable name="relevant.elements" select="$mei.source//tei:elementSpec[.//tei:memberOf[@key = $current.class/@ident] or .//tei:content//rng:ref[@name = $current.class/@ident]]" as="node()*"/>
            
            <xsl:choose>
                <xsl:when test="count($relevant.elements) gt 0">
                    <div>
                        <xsl:for-each select="$relevant.elements">
                            <xsl:choose>
                                <xsl:when test="$target = 'website'">
                                    <xsl:value-of select="if(position() gt 1) then(', ') else('')"/><a class="link_odd_elementSpec" href="/documentation/{$version}/{@ident}"><xsl:value-of select="@ident"/></a>                                    
                                </xsl:when>
                                <xsl:when test="$target = 'pdf'">
                                    <xsl:value-of select="if(position() gt 1) then(', ') else('')"/><a class="link_odd_elementSpec" href="#{@ident}"><xsl:value-of select="@ident"/></a>
                                </xsl:when>
                                <xsl:otherwise>
                                    <xsl:message terminate="yes" select="'ERROR: Cannot identify target medium.'"/>
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:for-each>
                        <xsl:choose>
                            <xsl:when test="$target = 'website'">
                                <span> (via <a class="link_odd_classSpec" href="/documentation/{$version}/{$current.class/@ident}"><xsl:value-of select="$current.class/@ident"/></a>)</span>
                            </xsl:when>
                            <xsl:when test="$target = 'pdf'">
                                <span> (via <a class="link_odd_classSpec" href="#{$current.class/@ident}"><xsl:value-of select="$current.class/@ident"/></a>)</span>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:message terminate="yes" select="'ERROR: Cannot identify target medium.'"/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </div>
                </xsl:when>
                <xsl:otherwise>
                    <div>
                        <xsl:choose>
                            <xsl:when test="$target = 'website'">
                                <span><a class="link_odd_classSpec" href="/documentation/{$version}/{$current.class/@ident}"><xsl:value-of select="$current.class/@ident"/></a> (no elements directly inheriting from this class)</span>
                            </xsl:when>
                            <xsl:when test="$target = 'pdf'">
                                <span><a class="link_odd_classSpec" href="#{$current.class/@ident}"><xsl:value-of select="$current.class/@ident"/></a> (no elements directly inheriting from this class)</span>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:message terminate="yes" select="'ERROR: Cannot identify target medium.'"/>
                            </xsl:otherwise>
                        </xsl:choose>   
                    </div>
                </xsl:otherwise>
            </xsl:choose>
            
            <xsl:sequence select="local:getElementsByModelClass($current.class/@ident)"/>
        </xsl:for-each>
    </xsl:function>
    
    <!-- resolve data types -->
    <xsl:template match="tei:macroSpec">
        
        <xsl:variable name="macroSpec" select="." as="node()"/>
        <div class="macroSpec">
            <h3 id="{@ident}"><xsl:value-of select="@ident"/></h3>
            <table class="wovenodd">
                <tr>
                    <td colspan="2" class="wovenodd-col2">
                        <span class="label"><xsl:value-of select="@ident"/> </span>
                        <xsl:value-of select="' '"/><xsl:value-of select="$macroSpec/tei:desc/text()"/>
                    </td>
                </tr>
                <tr>
                    <td class="wovenodd-col1"><span class="label" lang="en">Module</span></td>
                    <td class="wovenodd-col2"><xsl:value-of select="$macroSpec/@module"/></td>
                </tr>
                <tr>
                    <td class="wovenodd-col1"><span class="label" lang="en">Used by</span></td>
                    <td class="wovenodd-col2">
                        <div class="parent">
                            
                            <xsl:variable name="dataTypes" select="$data.types/descendant-or-self::tei:macroSpec[.//tei:macroRef[@key = $macroSpec/@ident]]" as="node()*"/>
                            <xsl:variable name="attClasses" select="$att.classes/descendant-or-self::tei:classSpec[.//rng:ref[@name = $macroSpec/@ident]]" as="node()*"/>
                            <xsl:variable name="relevantElements" select="$elements/descendant-or-self::tei:elementSpec[.//rng:ref[@name = $macroSpec/@ident]]" as="node()*"/>
                            
                            <xsl:choose>
                                <xsl:when test="$target = 'website'">
                                    <xsl:for-each select="($dataTypes | $attClasses | $relevantElements)">
                                        <xsl:variable name="ref" select="." as="node()"/>
                                        <xsl:if test="position() gt 1">
                                            <xsl:value-of select="', '"/>
                                        </xsl:if>
                                        <xsl:variable name="subref" select="$ref//tei:attDef[.//rng:ref[@name = $macroSpec/@ident]][1]/@ident" as="xs:string?"/>
                                        <xsl:choose>
                                            <xsl:when test="local-name($ref) = 'macroSpec'">
                                                <a class="link_odd" href="/documentation/{$version}/{$ref/@ident}"><xsl:value-of select="$ref/@ident"/></a>
                                            </xsl:when>
                                            <xsl:when test="local-name($ref) = 'classSpec'">
                                                <a class="link_odd_classSpec" href="/documentation/{$version}/{$ref/@ident}"><xsl:value-of select="$ref/@ident"/></a><xsl:value-of select="if($subref) then(' (@' || $subref ||')') else()"/>
                                            </xsl:when>
                                            <xsl:when test="local-name($ref) = 'elementSpec'">
                                                <a class="link_odd_classSpec" href="/documentation/{$version}/{$ref/@ident}"><xsl:value-of select="$ref/@ident"/></a><xsl:value-of select="if($subref) then('/@' || $subref) else()"/>
                                            </xsl:when>
                                            <xsl:otherwise>
                                                <xsl:message terminate="no" select="'ERROR: Unable to resolve reference to ' || $macroSpec/@ident || ' from a ' || local-name($ref)"/>
                                            </xsl:otherwise>
                                        </xsl:choose>
                                    </xsl:for-each>                     
                                </xsl:when>
                                <xsl:when test="$target = 'pdf'">
                                    <xsl:for-each select="($dataTypes | $attClasses | $relevantElements)">
                                        <xsl:variable name="ref" select="." as="node()"/>
                                        <xsl:if test="position() gt 1">
                                            <xsl:value-of select="', '"/>
                                        </xsl:if>
                                        <xsl:variable name="subref" select="$ref//tei:attDef[.//rng:ref[@name = $macroSpec/@ident]][1]/@ident" as="xs:string?"/>
                                        <xsl:choose>
                                            <xsl:when test="local-name($ref) = 'macroSpec'">
                                                <a class="link_odd" href="#{$ref/@ident}"><xsl:value-of select="$ref/@ident"/></a>
                                            </xsl:when>
                                            <xsl:when test="local-name($ref) = 'classSpec'">
                                                <a class="link_odd_classSpec" href="#{$ref/@ident}"><xsl:value-of select="$ref/@ident"/></a><xsl:value-of select="if($subref) then(' (@' || $subref ||')') else()"/>
                                            </xsl:when>
                                            <xsl:when test="local-name($ref) = 'elementSpec'">
                                                <a class="link_odd_classSpec" href="#{$ref/@ident}"><xsl:value-of select="$ref/@ident"/></a><xsl:value-of select="if($subref) then('/@' || $subref) else()"/>
                                            </xsl:when>
                                            <xsl:otherwise>
                                                <xsl:message terminate="no" select="'ERROR: Unable to resolve reference to ' || $macroSpec/@ident || ' from a ' || local-name($ref)"/>
                                            </xsl:otherwise>
                                        </xsl:choose>
                                    </xsl:for-each>
                                </xsl:when>
                                <xsl:otherwise>
                                    <xsl:message terminate="yes" select="'ERROR: Unable to retrieve target medium.'"/>
                                </xsl:otherwise>
                            </xsl:choose>
                        </div>
                    </td>
                </tr>
                <xsl:if test="$macroSpec//tei:valList">
                    <tr>
                        <td class="wovenodd-col1"><span class="label" lang="en">Allowed values</span></td>
                        <td class="wovenodd-col2">
                            <dl>
                                <xsl:for-each select="$macroSpec//tei:valList/tei:valItem">
                                    <dt><xsl:value-of select="@ident"/></dt><dd><xsl:value-of select="tei:desc/text()"/></dd>
                                </xsl:for-each>
                            </dl>
                        </td>
                    </tr>
                </xsl:if>
                <xsl:if test="$macroSpec/tei:content">
                    <tr>
                        <td class="wovenodd-col1"><span class="label" lang="en">Declaration</span></td>
                        <td class="wovenodd-col2">
                            <div xml:space="preserve" class="pre"><xsl:apply-templates select="$macroSpec/tei:content" mode="preserveSpace"><xsl:with-param name="getODD" tunnel="yes" select="true()"/></xsl:apply-templates></div>
                        </td>
                    </tr>    
                </xsl:if>
                <xsl:if test="$macroSpec/tei:remarks">
                    <tr>
                        <td class="wovenodd-col1"><span class="label" lang="en">Remarks</span></td>
                        <td class="wovenodd-col2">
                            <p><xsl:apply-templates select="$macroSpec/tei:remarks/tei:p/node()"/></p>
                        </td>
                    </tr>
                </xsl:if>
                <xsl:for-each select="$macroSpec//tei:constraintSpec">
                    <tr>
                        <td class="wovenodd-col1"><span class="label" lang="en">Constraints</span></td>
                        <td class="wovenodd-col2">
                            <div>
                                <xsl:for-each select=".//sch:assert">
                                    <div><xsl:value-of select="normalize-space(string-join(.//text(),' '))"/></div>
                                </xsl:for-each>
                            </div>
                            <div xml:space="preserve" class="pre"><xsl:apply-templates select=".//sch:rule" mode="preserveSpace"/></div>
                        </td>
                    </tr>
                </xsl:for-each>
            </table>
        </div>
    </xsl:template>
    
    <xsl:template match="tei:content" mode="parseMacroSpec">
        <xsl:apply-templates select="." mode="preserveSpace">
            <xsl:with-param name="getODD" tunnel="yes" select="true()"/>
        </xsl:apply-templates>
        <!-- zeroOrMore -->
        <!-- optional -->
        <!-- empty -->
        <!-- element -->
        <!-- data -->
        <!-- choice -->
        <!-- alternate -->
        
        <!-- valList -->
    </xsl:template>
    
    
    
    <!-- generic templates -->
    
    <xsl:template match="tei:*" mode="#all">
        <!--<xsl:message select="'DEBUG: processing tei:' || local-name()"/>-->
        <span class="{local-name()}">
            <xsl:apply-templates select="node()" mode="#current"/>
        </span>
    </xsl:template>
    
    <xsl:template match="rng:*" mode="#all">
        <!--<xsl:message select="'DEBUG: processing tei:' || local-name()"/>-->
        <span class="{local-name()}">
            <xsl:apply-templates select="node()" mode="#current"/>
        </span>
    </xsl:template>
    
    <!-- in order to preserve spacing, it is important that the following template is kept on one line -->
    <xsl:template match="element()" mode="preserveSpace" priority="1">
        <xsl:param name="indent" as="xs:integer?"/>
        <xsl:variable name="indent.level" select="if($indent) then($indent) else(1)" as="xs:integer"/>
        <xsl:variable name="element" select="." as="node()"/>
        <xsl:choose>
            <xsl:when test="local-name() = 'param' and @name = 'pattern' and string-length(text()) gt 30">
                <div class="indent{$indent.level}"><span data-indentation="{$indent.level}" class="element">&lt;<xsl:value-of select="name($element)"/><xsl:apply-templates select="$element/@*" mode="#current"/>&gt;</span>
                    <xsl:choose>
                        <xsl:when test="string-length(text()) gt 240">
                            <div class="indent{$indent.level + 1}"><xsl:value-of select="substring(text(),1,60)"/></div>
                            <div class="indent{$indent.level + 2}"><xsl:value-of select="substring(text(),61,60)"/></div>
                            <div class="indent{$indent.level + 2}"><xsl:value-of select="substring(text(),121,60)"/></div>
                            <div class="indent{$indent.level + 2}"><xsl:value-of select="substring(text(),181,60)"/></div>
                            <div class="indent{$indent.level + 2}"><xsl:value-of select="substring(text(),241,60)"/></div>
                        </xsl:when>
                        <xsl:when test="string-length(text()) gt 180">
                            <div class="indent{$indent.level + 1}"><xsl:value-of select="substring(text(),1,60)"/></div>
                            <div class="indent{$indent.level + 2}"><xsl:value-of select="substring(text(),61,60)"/></div>
                            <div class="indent{$indent.level + 2}"><xsl:value-of select="substring(text(),121,60)"/></div>
                            <div class="indent{$indent.level + 2}"><xsl:value-of select="substring(text(),181,60)"/></div>
                        </xsl:when>
                        <xsl:when test="string-length(text()) gt 120">
                            <div class="indent{$indent.level + 1}"><xsl:value-of select="substring(text(),1,60)"/></div>
                            <div class="indent{$indent.level + 2}"><xsl:value-of select="substring(text(),61,60)"/></div>
                            <div class="indent{$indent.level + 2}"><xsl:value-of select="substring(text(),121,60)"/></div>
                        </xsl:when>
                        <xsl:when test="string-length(text()) gt 60">
                            <div class="indent{$indent.level + 1}"><xsl:value-of select="substring(text(),1,60)"/></div>
                            <div class="indent{$indent.level + 2}"><xsl:value-of select="substring(text(),61,60)"/></div>
                        </xsl:when>
                        <xsl:when test="string-length(text()) gt 30">
                            <div class="indent{$indent.level + 1}"><xsl:value-of select="substring(text(),1,100)"/></div>        
                        </xsl:when>
                    </xsl:choose>
                <span data-indentation="{$indent.level}" class="element">&lt;/<xsl:value-of select="name($element)"/>&gt;</span></div>
            </xsl:when>
            <xsl:otherwise>
                <div class="indent{$indent.level}"><span data-indentation="{$indent.level}" class="element">&lt;<xsl:value-of select="name($element)"/><xsl:apply-templates select="$element/@*" mode="#current"/><xsl:if test="not($element/node())">/</xsl:if>&gt;</span><xsl:apply-templates select="$element/node()" mode="#current"><xsl:with-param name="indent" select="$indent.level + 1" as="xs:integer"/></xsl:apply-templates><xsl:if test="$element/node()"><span data-indentation="{$indent.level}" class="element">&lt;/<xsl:value-of select="name($element)"/>&gt;</span></xsl:if></div>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    
    <!-- in order to preserve spacing, it is important that the following template is kept on one line -->
    <xsl:template match="comment()" mode="preserveSpace" priority="1">
        <xsl:param name="indent" as="xs:integer?"/>
        <xsl:variable name="indent.level" select="if($indent) then($indent) else(1)" as="xs:integer"/>
        <xsl:variable name="element" select="." as="node()"/>
        <div class="indent{$indent.level}"><span data-indentation="{$indent.level}" class="comment">&lt;!--<xsl:value-of select="."/>--&gt;</span></div>   
    </xsl:template>
    
    <!-- in order to preserve spacing, it is important that the following template is kept on one line -->
    <xsl:template match="@*" mode="preserveSpace" priority="1"><xsl:value-of select="' '"/><span class="attribute"><xsl:value-of select="name()"/>=</span><span class="attributevalue">"<xsl:value-of select="string(.)"/>"</span></xsl:template>
    
    <!-- in order to preserve spacing, it is important that the following template is kept on one line -->
    <xsl:template match="tei:memberOf/@key" mode="preserveSpace" priority="2"><xsl:value-of select="' '"/><span class="attribute"><xsl:value-of select="local-name()"/>=</span><span class="attributevalue">"<a class="link_odd" href="{(if($target = 'website')then('/documentation/' || $version || '/') else('#'))}{string(.)}"><xsl:value-of select="string(.)"/></a>"</span></xsl:template>
    
    <!-- in order to preserve spacing, it is important that the following template is kept on one line -->
    <xsl:template match="tei:macroRef/@key" mode="preserveSpace" priority="2"><xsl:value-of select="' '"/><span class="attribute"><xsl:value-of select="local-name()"/>=</span><span class="attributevalue">"<a class="link_odd" href="{(if($target = 'website')then('/documentation/' || $version || '/') else('#'))}{string(.)}"><xsl:value-of select="string(.)"/></a>"</span></xsl:template>
    
    <!-- in order to preserve spacing, it is important that the following template is kept on one line -->
    <xsl:template match="rng:ref/@name" mode="preserveSpace" priority="2"><xsl:value-of select="' '"/><span class="attribute"><xsl:value-of select="local-name()"/>=</span><span class="attributevalue">"<a class="link_odd" href="{(if($target = 'website')then('/documentation/' || $version || '/') else('#'))}{string(.)}"><xsl:value-of select="string(.)"/></a>"</span></xsl:template>
    
    <xsl:template match="@mode[not(ancestor::egx:egXML)]" mode="preserveSpace" priority="2">
        <xsl:param name="getODD" tunnel="yes" as="xs:boolean?"/>
        <!--<xsl:if test="not($getODD) or $getODD = false()">
            <xsl:next-match/>
        </xsl:if>-->
    </xsl:template>
    
    <!-- remove attributes for elementSpec's ODD -->
    <xsl:template match="tei:elementSpec//@ns | tei:elementSpec//@predeclare | tei:elementSpec//@status | tei:elementSpec//@autoPrefix" mode="preserveSpace" priority="2">
        <xsl:param name="getODD" tunnel="yes" as="xs:boolean?"/>
        <!--<xsl:if test="not($getODD) or $getODD = false()">
            <xsl:next-match/>
        </xsl:if>-->
    </xsl:template>
    
    <!-- remove attributes for classSpec's ODD -->
    <xsl:template match="tei:classSpec//@ns | tei:classSpec//@predeclare | tei:classSpec//@status | tei:classSpec//@autoPrefix" mode="preserveSpace" priority="2">
        <xsl:param name="getODD" tunnel="yes" as="xs:boolean?"/>
        <!--<xsl:if test="not($getODD) or $getODD = false()">
            <xsl:next-match/>
        </xsl:if>-->
    </xsl:template>
    
    <!-- remove attributes for macroSpec's ODD -->
    <xsl:template match="tei:macroSpec//@ns | tei:macroSpec//@predeclare | tei:macroSpec//@status | tei:macroSpec//@autoPrefix" mode="preserveSpace" priority="2">
        <xsl:param name="getODD" tunnel="yes" as="xs:boolean?"/>
        <!--<xsl:if test="not($getODD) or $getODD = false()">
            <xsl:next-match/>
        </xsl:if>-->
    </xsl:template>
    
    <!-- the following templates are used to support the unicode "reverse solidus overlay" character (u20E5) -->
    <xsl:template match="tei:p[following-sibling::*[1][local-name() = 'figure'][child::tei:graphic/@url = 'Images/modules/harmony/figuredBass05.png']]/text()" priority="1">
        <xsl:choose>
            <xsl:when test="contains(.,'âƒ¥')">
                <xsl:value-of select="substring-before(.,'âƒ¥')"/><span class="reverseSolidus">âƒ¥</span><xsl:value-of select="substring-after(.,'âƒ¥')"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:next-match/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="*:egXML/*:harm/*:fb/*:f/text()" mode="#all" priority="1">
        <xsl:choose>
            <xsl:when test="contains(.,'âƒ¥')">
                <xsl:value-of select="substring-before(.,'âƒ¥')"/><span class="reverseSolidus">âƒ¥</span><xsl:value-of select="substring-after(.,'âƒ¥')"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:next-match/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    
    <xd:doc scope="component">
        <xd:desc>
            <xd:p>
                The following template provides the general frame for a complete HTML file with all contents
            </xd:p>
        </xd:desc>
    </xd:doc>
    <xsl:template name="getSinglePage">
        <xsl:param name="contents" as="node()*"/>
        
        <html xml:lang="en">
            <head>
                <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
                <xsl:comment>THIS FILE IS GENERATED FROM AN XML MASTER. DO NOT EDIT!</xsl:comment>
                <title>Music Encoding Initiative Guidelines</title>
                <meta name="author" content="Perry D. Roland, Johannes Kepper" />
                <meta name="subject" content="Documentation for the Music Encoding Initiative (MEI) Data Model" />
                <meta name="keywords" content="Music Encoding, MEI, Digital Humanities, Music, Musicology, Music Librarianship, Music Information Retrieval" />
                <meta name="date" content="{substring(string(current-date()),1,10)}" />
                <meta name="generator" content="MEI XSLT stylesheets" />
                <meta name="DC.Title" content="Music Encoding Initiative Guidelines" />
                <meta name="DC.Type" content="Text" />
                <meta name="DC.Format" content="text/html" />
                <link rel="stylesheet" media="print" type="text/css"
                    href="css/mei-print.css" />
                <link href="css/mei.css" media="print" rel="stylesheet"
                    type="text/css" />
                
            </head>
            <body class="simple" id="TOP">
                <section id="dataStore" style="display: none;">
                    <div id="versionInfo" data-version="{$version}"/>
                    <div id="roleInfo">
                        <xsl:choose>
                            <xsl:when test="$role = 'release'"> Release <xsl:value-of select="$version"/></xsl:when>
                            <xsl:when test="$role = 'dev'">(latest development revision, PDF generated on <xsl:value-of select="substring(string(current-date()),1,10)"/>)</xsl:when>
                            <xsl:when test="$role = 'custom'">(customization, based on <xsl:value-of select="$version"/>, PDF generated on <xsl:value-of select="substring(string(current-date()),1,10)"/>)</xsl:when>
                        </xsl:choose>
                    </div>
                </section>
                <div class="titlePage">
                    <div class="docTitle">
                        <div class="titlePart">
                            Music Encoding Initiative Guidelines
                        </div>
                        <xsl:choose>
                            <xsl:when test="$role = 'release'">
                                <div class="versionInfo">Version <xsl:value-of select="$version"/></div>
                            </xsl:when>
                            <xsl:when test="$role = 'dev'">
                                <div class="versionInfo">Latest development revision, based on Version <xsl:value-of select="$version"/></div>
                            </xsl:when>
                            <xsl:when test="$role = 'custom'">
                                <div class="versionInfo">Customization, based on Version <xsl:value-of select="$version"/></div>
                            </xsl:when>
                        </xsl:choose>
                        
                    </div>
                    <div class="byline">
                        <xsl:choose>
                            <xsl:when test="$role = 'release'">
                                Prepared and maintained by the Music Encoding Initiative Board        
                            </xsl:when>
                            <xsl:when test="$role = 'dev'">
                                Developed by the Music Encoding Initiative Technical Team        
                            </xsl:when>
                            <xsl:when test="$role = 'custom'">
                                        
                            </xsl:when>
                        </xsl:choose>
                    </div>
                    <div class="figure meiLogo">
                        <img src="Images/meilogo.png" alt="" class="graphic" />
                    </div>
                    <div class="byline editors">
                        <xsl:choose>
                            <xsl:when test="$role = 'custom'">
                                Based on original work edited by Perry Roland and Johannes Kepper<br />
                                <br />
                                With contributions by Benjamin Bohl, Andrew Hankinson, Maja Hartwig, ZoltÃ¡n KÃ¶mÃ­ves, Laurent Pugin,<br /> 
                                Kristina Richts, Axel Teich Geertinger, Raffaele Viglianti, and Thomas Weber 
                            </xsl:when>
                            <xsl:otherwise>
                                Edited by Perry Roland and Johannes Kepper<br />
                                <br />
                                With contributions by Benjamin Bohl, Andrew Hankinson, Maja Hartwig, ZoltÃ¡n KÃ¶mÃ­ves, Laurent Pugin,<br /> 
                                Kristina Richts, Axel Teich Geertinger, Raffaele Viglianti, and Thomas Weber      
                            </xsl:otherwise>
                        </xsl:choose>
                    </div>
                    <div class="docImprint beginPages">
                        <xsl:choose>
                            <xsl:when test="$role = 'custom'">
                                <div class="copyright">Â© for original Guidelines by the Music Encoding Initiative (MEI) Board.</div>
                            </xsl:when>
                            <xsl:otherwise>
                                <div class="copyright">Â© by the Music Encoding Initiative (MEI) Board.</div>
                            </xsl:otherwise>
                        </xsl:choose>
                        <div>
                            <span class="pubPlace">Charlottesville and Detmold</span>.
                            <span class="docDate"><xsl:value-of select="$imprint.date"/></span>
                        </div>
                        <div class="license">
                            Licensed under the Educational Community License, Version 2.0 (the "License"); you
                            may not use this file except in compliance with the License. You may obtain a copy
                            of the License at <a class="link_ref" href="http://opensource.org/licenses/ECL-2.0">http://opensource.org/licenses/ECL-2.0</a>.
                        </div>
                    </div>
                </div>
                
                <!-- toc -->
                <div class="teidiv0 alsoBegin" id="toc">
                    <div class="tei_toc">
                        <h2>Table of contents</h2>
                        <xsl:if test="$role = ('release','dev')">
                            <ul class="toc toc_front">
                                <xsl:for-each select="$mei.source//tei:front/tei:div[not(./tei:divGen[@type = 'toc'])]">
                                    <li class="toc">
                                        <a class="toc toc_0" href="#frontChapter_{position()}"><xsl:value-of select="child::tei:head[1]/text()"/></a>
                                    </li>
                                </xsl:for-each>
                            </ul>
                            <ul class="toc toc_body">
                                <!-- this generates the table of contents. avoiding recursion for clarity -->
                                <xsl:for-each select="$all.chapters/*[@level = '1']">
                                    <xsl:variable name="tocInfo.1" select="." as="node()"/>
                                    <li class="toc">
                                        <span class="headingNumber"><xsl:value-of select="$tocInfo.1/@number"/>. </span>
                                        <a class="toc toc_0" href="#{$tocInfo.1/@xml:id}" title="{$tocInfo.1/@head}"><xsl:value-of select="$tocInfo.1/@head"/></a>
                                        <xsl:if test="$tocInfo.1/following-sibling::*[@parent.id = $tocInfo.1/@xml:id]">
                                            <ul class="toc">
                                                <xsl:for-each select="$tocInfo.1/following-sibling::*[@parent.id = $tocInfo.1/@xml:id]">
                                                    
                                                    <xsl:variable name="tocInfo.2" select="." as="node()"/>
                                                    <li class="toc">
                                                        <span class="headingNumber"><xsl:value-of select="$tocInfo.2/@number"/>. </span>
                                                        <a class="toc toc_1" href="#{$tocInfo.2/@xml:id}" title="{$tocInfo.2/@head}"><xsl:value-of select="$tocInfo.2/@head"/></a>
                                                        <xsl:if test="$tocInfo.2/following-sibling::*[@parent.id = $tocInfo.2/@xml:id]">
                                                            <ul class="toc">
                                                                <xsl:for-each select="$tocInfo.1/following-sibling::*[@parent.id = $tocInfo.2/@xml:id]">
                                                                    
                                                                    <xsl:variable name="tocInfo.3" select="." as="node()"/>
                                                                    <li class="toc">
                                                                        <span class="headingNumber"><xsl:value-of select="$tocInfo.3/@number"/>. </span>
                                                                        <a class="toc toc_2" href="#{$tocInfo.3/@xml:id}" title="{$tocInfo.3/@head}"><xsl:value-of select="$tocInfo.3/@head"/></a>
                                                                        <xsl:if test="$tocInfo.3/following-sibling::*[@parent.id = $tocInfo.3/@xml:id]">
                                                                            <ul class="toc">
                                                                                <xsl:for-each select="$tocInfo.3/following-sibling::*[@parent.id = $tocInfo.3/@xml:id]">
                                                                                    
                                                                                    <xsl:variable name="tocInfo.4" select="." as="node()"/>
                                                                                    <li class="toc">
                                                                                        <span class="headingNumber"><xsl:value-of select="$tocInfo.4/@number"/>. </span>
                                                                                        <a class="toc toc_3" href="#{$tocInfo.4/@xml:id}" title="{$tocInfo.4/@head}"><xsl:value-of select="$tocInfo.4/@head"/></a>
                                                                                        <xsl:if test="$tocInfo.4/following-sibling::*[@parent.id = $tocInfo.4/@xml:id]">
                                                                                            <ul class="toc">
                                                                                                <xsl:for-each select="$tocInfo.4/following-sibling::*[@parent.id = $tocInfo.4/@xml:id]">
                                                                                                    
                                                                                                    <xsl:variable name="tocInfo.5" select="." as="node()"/>
                                                                                                    <li class="toc">
                                                                                                        <span class="headingNumber"><xsl:value-of select="$tocInfo.5/@number"/>. </span>
                                                                                                        <a class="toc toc_4" href="#{$tocInfo.5/@xml:id}" title="{$tocInfo.5/@head}"><xsl:value-of select="$tocInfo.5/@head"/></a>
                                                                                                    </li>
                                                                                                    
                                                                                                </xsl:for-each>
                                                                                            </ul>
                                                                                        </xsl:if>
                                                                                    </li>
                                                                                    
                                                                                </xsl:for-each>
                                                                            </ul>
                                                                        </xsl:if>
                                                                    </li>
                                                                    
                                                                </xsl:for-each>
                                                            </ul>
                                                        </xsl:if>
                                                    </li>
                                                    
                                                </xsl:for-each>
                                            </ul>
                                        </xsl:if>
                                    </li>
                                </xsl:for-each>
                            </ul>
                        </xsl:if>
                        
                        <ul class="toc toc_back">
                            <li class="toc">
                                
                                <a class="toc toc_0" href="#appendix">MEI Data Dictionary</a>        
                                    
                                <ul class="toc">
                                    
                                    <xsl:for-each select="$mei.source//tei:back/tei:div[@xml:id='DataDictConv']">
                                        <li class="toc">
                                            <a class="toc toc_1" href="#{@xml:id}"><xsl:value-of select="child::tei:head[1]/text()"/></a>
                                            <xsl:if test="child::tei:div">
                                                <ul class="toc">
                                                    <xsl:for-each select="child::tei:div">
                                                        <li class="toc">
                                                            <a class="toc toc_2" href="#{@xml:id}"><xsl:value-of select="child::tei:head[1]/text()"/></a>
                                                            <xsl:if test="child::tei:div">
                                                                <ul class="toc">
                                                                    <xsl:for-each select="child::tei:div">
                                                                        <li class="toc">
                                                                            <a class="toc toc_3" href="#{@xml:id}"><xsl:value-of select="child::tei:head[1]/text()"/></a>
                                                                        </li>
                                                                    </xsl:for-each> 
                                                                </ul>
                                                            </xsl:if>
                                                        </li>
                                                    </xsl:for-each> 
                                                </ul>
                                            </xsl:if>
                                        </li>
                                        
                                    </xsl:for-each>
                                    
                                    <li class="toc">
                                        <a class="toc toc_1" href="#appendix_Elements">Elements</a>
                                    </li>
                                    <li class="toc">
                                        <a class="toc toc_1" href="#appendix_Models">Model Classes</a>
                                    </li>
                                    <li class="toc">
                                        <a class="toc toc_1" href="#appendix_Atts">Attribute Classes</a>
                                    </li>
                                    <li class="toc">
                                        <a class="toc toc_1" href="#appendix_DataMacros">Datatypes and Macros</a>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                </div>
                
                <xsl:if test="not($role = 'custom')">
                    <!-- Preface, Acknowledgements and Introduction -->
                    <xsl:for-each select="$mei.source//tei:front/tei:div[not(./tei:divGen[@type = 'toc'])]">
                        <div class="teidiv0 alsoBegin" id="frontChapter_{position()}">
                            <xsl:apply-templates select="node()"/>
                        </div>
                    </xsl:for-each>
                </xsl:if>
                
                <!-- chapters go here -->
                <div class="regularPage">
                    
                    <xsl:if test="not($role = 'custom')">
                        <xsl:sequence select="$contents[local-name() = 'section']"/>
                    </xsl:if>
                    
                    <section id="tei_back">
                        <h1 id="appendix">MEI Data Dictionary</h1>
                        <div>
                            <xsl:apply-templates select="$mei.source//tei:back/tei:div[@xml:id='DataDictConv']"/>
                        </div>
                        <div>
                            <h2 id="appendix_Elements"><span class="headingNumber"/><span class="head">Elements</span></h2>
                            <xsl:sequence select="$contents[local-name() = 'div' and @class='elementSpec']"/>
                        </div>
                        <div>
                            <h2 id="appendix_Models"><span class="headingNumber"/><span class="head">Model Classes</span></h2>
                            <xsl:sequence select="$contents[local-name() = 'div' and @class='classSpec model']"/>
                        </div>
                        <div>
                            <h2 id="appendix_Atts"><span class="headingNumber"/><span class="head">Attribute Classes</span></h2>
                            <xsl:sequence select="$contents[local-name() = 'div' and @class='classSpec att']"/>
                        </div>
                        <div>
                            <h2 id="appendix_DataMacros"><span class="headingNumber"/><span class="head">Datatypes and Macros</span></h2>
                            <xsl:sequence select="$contents[local-name() = 'div' and @class='macroSpec']"/>
                        </div>
                    </section>
                </div>
            </body>
        </html>
    </xsl:template>
    
    <xsl:template match="node() | @*" mode="#all">
        <xsl:copy>
            <xsl:apply-templates select="node() | @*" mode="#current"/>
        </xsl:copy>
    </xsl:template>
    
</xsl:stylesheet>