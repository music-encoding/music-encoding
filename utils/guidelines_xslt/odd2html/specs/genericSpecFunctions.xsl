<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:math="http://www.w3.org/2005/xpath-functions/math"
    xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl"
    xmlns:tei="http://www.tei-c.org/ns/1.0"
    xmlns:egx="http://www.tei-c.org/ns/Examples"
    xmlns:xhtml="http://www.w3.org/1999/xhtml"
    xmlns:rng="http://relaxng.org/ns/structure/1.0"
    xmlns:sch="http://purl.oclc.org/dsdl/schematron"
    xmlns:tools="no:where"
    exclude-result-prefixes="xs math xd xhtml tei tools rng sch egx"
    version="3.0">
    <xd:doc scope="stylesheet">
        <xd:desc>
            <xd:p><xd:b>Created on:</xd:b> Nov 12, 2020</xd:p>
            <xd:p><xd:b>Author:</xd:b> Johannes Kepper</xd:p>
            <xd:p>This file holds generic tools for dealing with spec pages and dependencies of elements. </xd:p>
        </xd:desc>
    </xd:doc>
    
    <xd:doc>
        <xd:desc>
            <xd:p>Creates a facet with chapter references for spec pages</xd:p>
        </xd:desc>
        <xd:param name="links">The links generated by the tools:getReferencingChapters() function</xd:param>
        <xd:return>the facet div, if any</xd:return>
    </xd:doc>
    <xsl:function name="tools:getReferencesFacet" as="node()?">
        <xsl:param name="links" as="node()*"/>
        
        <xsl:if test="count($links) gt 0">
            <div class="chapterLinksBox">
                <xsl:for-each select="$links">
                    <xsl:if test="position() gt 1"><xsl:value-of select="', '"/></xsl:if><xsl:sequence select="."/>
                </xsl:for-each>
            </div>
        </xsl:if>
    </xsl:function>
    
    <xd:doc>
        <xd:desc>
            <xd:p>Creates a facet with module information</xd:p>
        </xd:desc>
        <xd:param name="object">The object for this facet is needed</xd:param>
        <xd:return>The resulting div</xd:return>
    </xd:doc>
    <xsl:function name="tools:getModuleFacet" as="node()">
        <xsl:param name="object" as="node()"/>
        <xsl:variable name="facetId" select="$object/@module" as="xs:string"/>
        <div class="facet module">
            <div class="label">Module</div>
            <div class="statement text">
                <a href="../modules/{$facetId}.html"><xsl:value-of select="$facetId"/></a>
            </div>
        </div>
    </xsl:function>
    
    <xd:doc>
        <xd:desc>
            <xd:p>Return a facet with tabs</xd:p>
        </xd:desc>
        <xd:param name="facetId">the supposed ID for the facet</xd:param>
        <xd:param name="facetLabel">the label of the facet</xd:param>
        <xd:param name="contents">the contents</xd:param>
        <xd:return></xd:return>
    </xd:doc>
    <xsl:function name="tools:getTabbedFacet" as="node()">
        <xsl:param name="facetId" as="xs:string"/>
        <xsl:param name="facetLabel" as="xs:string"/>
        <xsl:param name="contents" as="node()+"/>
        
        <div class="facet {$facetId}" id="{$facetId}">
            <div class="label"><xsl:value-of select="$facetLabel"/></div>
            <div class="statement classes list">
                <ul class="tab">
                    <xsl:for-each select="$contents/self::tab">
                        <li class="tab-item">
                            <a data-display="{@id}" 
                                id="{$facetId}_{@id}_tab"
                                href="#{$facetId}"
                                class="displayTab{if(position() = 1) then(' active') else()}"><xsl:value-of select="@label"/></a>
                        </li>
                    </xsl:for-each>
                </ul>
                <xsl:for-each select="$contents/self::tab">
                    <div id="{$facetId}_tabbedContent_{@id}"
                        class="facetTabbedContent {@id}{if(position() = 1) then(' active') else()}">
                        <xsl:sequence select="child::node()"/>
                    </div>
                </xsl:for-each>
            </div>
        </div>
        
    </xsl:function>
    
    <xd:doc>
        <xd:desc>
            <xd:p>Creates a box for displaying (nested) classes, both attribute and model</xd:p>
        </xd:desc>
        <xd:param name="label">The label of the class</xd:param>
        <xd:param name="desc">The description of the class</xd:param>
        <xd:param name="content">The contents of the class, if any</xd:param>
        <xd:param name="additional.class">additional CSS classes, if any</xd:param>
        <xd:return>The resulting div</xd:return>
    </xd:doc>
    <xsl:function name="tools:getClassBox" as="node()*">
        <xsl:param name="label"/><!-- no datatype specified – could be xs:string or node() -->
        <xsl:param name="desc"/><!-- no datatype specified – could be xs:string or node() -->
        <xsl:param name="content" as="node()*"/>
        <xsl:param name="additional.class" as="xs:string"/>
        
        <!--<div class="classBox{if($additional.class != '') then(' '||$additional.class) else()}" title="{$label}">
            <div class="classHeading">
                <label class="classLabel">
                    <xsl:choose>
                        <xsl:when test="$label = ($elements/@ident, $att.classes/@ident, $model.classes/@ident, $data.types/@ident, $macro.groups/@ident)">
                            <a class="{tools:getLinkClasses($label)}" href="#{$label}"><xsl:value-of select="$label"/></a>        
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of select="$label"/>
                        </xsl:otherwise>
                    </xsl:choose>
                                        
                </label>
                <span class="classDesc"><xsl:sequence select="$desc"/></span>
            </div>
            <div class="classContent">
                <xsl:sequence select="$content"/>
            </div>
        </div>-->
        
        <xsl:variable name="spec" select="$mei.source//tei:*[@ident = $label and not(local-name() = 'attDef')]" as="node()?"/>
        
        <group ident="{$label}" class="{$additional.class}" module="{$spec/@module}">
            <xsl:choose>
                <xsl:when test="not($label = 'direct children') and exists($spec)">
                    <xsl:attribute name="module" select="$spec/@module"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:attribute name="module" select="''"/>
                </xsl:otherwise>
            </xsl:choose>
            <link>
                <xsl:choose>
                    <xsl:when test="$label = ($elements/@ident, $att.classes/@ident, $model.classes/@ident, $data.types/@ident, $macro.groups/@ident)">
                        <a class="{tools:getLinkClasses($label)}" href="#{$label}"><xsl:value-of select="$label"/></a>        
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="$label"/>
                    </xsl:otherwise>
                </xsl:choose>
            </link>
            <desc><xsl:sequence select="$desc"/></desc>
            <xsl:sequence select="$content"/>
        </group>        
    </xsl:function>
    
    <xd:doc>
        <xd:desc>
            <xd:p>Gets a list with members of a model class or macro group</xd:p>
        </xd:desc>
        <xd:param name="object">the model class</xd:param>
        <xd:return>the resulting div</xd:return>
    </xd:doc>
    <xsl:function name="tools:getMembersFacet" as="node()">
        <xsl:param name="object" as="node()"/>
        
        <xsl:variable name="element.members" select="$elements/self::tei:elementSpec[.//tei:memberOf/@key = $object/@ident]" as="node()*"/>
        <xsl:variable name="class.members" select="$model.classes/self::tei:classSpec[.//tei:memberOf/@key = $object/@ident]" as="node()*"/>
        <xsl:variable name="members" select="$element.members | $class.members" as="node()*"/>
        
        <xsl:choose>
            <xsl:when test="count($members) gt 0">
                <!--<xsl:variable name="members.compact" as="node()*">
                    <xsl:for-each select="$members/self::tei:elementSpec">
                        <xsl:sort select="@ident" data-type="text"/>
                        <xsl:variable name="current.elem" select="@ident" as="xs:string"/>
                        <xsl:variable name="desc" select="normalize-space(string-join(tei:desc//text(),' '))" as="xs:string"/>
                        <xsl:if test="position() gt 1">
                            <xsl:value-of select="', '"/>
                        </xsl:if>
                        <span class="ident element" title="{$desc}">
                            <a class="link_odd_elementSpec" href="{tools:linkToElement($current.elem)}"><xsl:value-of select="$current.elem"/></a>
                        </span>
                    </xsl:for-each>
                </xsl:variable>-->
                <xsl:variable name="members.by.module" as="node()*">
                    <xsl:for-each select="distinct-values($members//@module)">
                        <xsl:sort select="." data-type="text"/>
                        <xsl:variable name="current.module" select="." as="xs:string"/>
                        <xsl:variable name="relevant.element.names" select="distinct-values($members/self::tei:elementSpec[@module = $current.module]/@ident)" as="xs:string*"/>
                        <xsl:variable name="relevant.class.names" select="distinct-values($members/self::tei:classSpec[@type='model'][@module = $current.module]/@ident)" as="xs:string*"/>
                        
                        <xsl:variable name="ident" select="$current.module" as="xs:string"/>
                        <xsl:variable name="desc" select="normalize-space(string-join($mei.source//tei:moduleSpec[@ident = $current.module]/tei:desc/text(),' '))" as="xs:string"/>
                        <!--<xsl:variable name="content" as="node()*">
                            <xsl:for-each select="$relevant.element.names">
                                <xsl:sort select="." data-type="text"/>
                                <xsl:variable name="current.elem" select="." as="xs:string"/>
                                
                                <div class="elementRef">
                                    <a class="{tools:getLinkClasses($current.elem)}" href="#{$current.elem}"><xsl:value-of select="$current.elem"/></a>        
                                    <span class="elementDesc">
                                        <xsl:apply-templates select="$elements/self::tei:elementSpec[@ident = $current.elem]/tei:desc" mode="guidelines"/>
                                    </span>
                                </div>
                            </xsl:for-each>
                        </xsl:variable>-->
                        <xsl:variable name="content" as="node()*">
                            <xsl:for-each select="distinct-values($relevant.element.names)">
                                <xsl:sort select="." data-type="text"/>
                                <xsl:variable name="current.elem" select="." as="xs:string"/>
                                <item class="element" ident="{$current.elem}" module="{$elements/self::tei:elementSpec[@ident = $current.elem]/@module}">
                                    <link><a class="{tools:getLinkClasses($current.elem)}" href="#{$current.elem}"><xsl:value-of select="$current.elem"/></a></link>
                                    <desc><xsl:apply-templates select="$elements/self::tei:elementSpec[@ident = $current.elem]/tei:desc" mode="guidelines"/></desc>
                                </item>
                            </xsl:for-each>
                            <xsl:for-each select="$relevant.class.names">
                                <xsl:sort select="." data-type="text"/>
                                <xsl:variable name="current.class" select="." as="xs:string"/>
                                <item class="modelClass" ident="{$current.class}" module="{$current.module}">
                                    <link><a class="{tools:getLinkClasses($current.class)}" href="#{$current.class}"><xsl:value-of select="$current.class"/></a></link>
                                    <desc><xsl:apply-templates select="$model.classes/self::tei:classSpec[@ident = $current.class]/tei:desc" mode="guidelines"/></desc>
                                </item>
                            </xsl:for-each>
                        </xsl:variable>
                        
                        <xsl:sequence select="tools:getClassBox($ident,$desc,$content,'')"/>
                        
                    </xsl:for-each>
                </xsl:variable>
                
                <!--<xsl:variable name="contents" as="node()+">
                    <tab id="compact" label="compact"><xsl:sequence select="$members.compact"/></tab>
                    <tab id="module" label="by module"><xsl:sequence select="$members.by.module"/></tab>
                </xsl:variable>
                
                <xsl:sequence select="tools:getTabbedFacet('members','Members',$contents)"/>   -->     
                
                <div class="facet members">
                    <div class="label">Members</div>
                    <div class="statement classes">
                        <xsl:sequence select="$members.by.module"/>
                    </div>
                </div>
            </xsl:when>
            <xsl:otherwise>
                <div class="facet members">
                    <div class="label">Members</div>
                    <div class="statement text">
                        – <span class="emptyStatement">(<em><xsl:value-of select="$object/@ident"/> has no members</em>)</span>
                    </div>
                </div>
            </xsl:otherwise>
        </xsl:choose>
        
    </xsl:function>
    
    <xd:doc>
        <xd:desc>
            <xd:p>Gets all elements that have access to a given att class</xd:p>
        </xd:desc>
        <xd:param name="object"></xd:param>
        <xd:return></xd:return>
    </xd:doc>
    <xsl:function name="tools:getElementsWithAttClassFacet" as="node()">
        <xsl:param name="object" as="node()"/>
        
        <xsl:variable name="content.by.class" as="node()*">
            <xsl:sequence select="tools:getAncestorsOfAttributeClass($object)"/>
        </xsl:variable>
        <!--<xsl:variable name="content.by.module">
            <xsl:for-each select="distinct-values($content.by.class//@data-module)">
                <xsl:sort select="lower-case(.)" data-type="text"/>
                <xsl:variable name="current.module" select="." as="xs:string"/>
                <xsl:variable name="relevant.elements" select="$content.by.class/descendant-or-self::div[@data-module = $current.module]" as="node()*"/>
                
                <xsl:sequence select="tools:getClassBox($current.module,'',$relevant.elements,'')"/>
                
            </xsl:for-each>
        </xsl:variable>-->
        <!--<xsl:variable name="content.compact" as="node()*">
            <xsl:for-each select="distinct-values($content.by.class/descendant-or-self::a[@class = 'link_odd_elementSpec']/text())">
                <xsl:sort select="lower-case(.)" data-type="text"/>
                <xsl:variable name="current.elem" select="." as="xs:string"/>
                <xsl:variable name="elementSpec" select="$elements/self::tei:elementSpec[@ident = $current.elem]" as="node()"/>
                <xsl:variable name="desc" select="normalize-space(string-join($elementSpec/tei:desc/text(),' '))" as="xs:string"/>
                <xsl:if test="position() gt 1">
                    <xsl:value-of select="', '"/>
                </xsl:if>
                <span class="ident element" title="{$desc}">
                    <a class="link_odd_elementSpec" href="{tools:linkToElement($current.elem)}"><xsl:value-of select="$current.elem"/></a>
                </span>
            </xsl:for-each>
            
        </xsl:variable>-->
        
        <!--<xsl:variable name="contents" as="node()+">
            <tab id="compact" label="compact"><xsl:sequence select="$content.compact"/></tab>
            <tab id="class" label="by class"><xsl:sequence select="$content.by.class"/></tab>
            <tab id="module" label="by module"><xsl:sequence select="$content.by.module"/></tab>
        </xsl:variable>
        
        <xsl:sequence select="tools:getTabbedFacet('availableAt','Available at',$contents)"/>-->
        
        <div class="facet availableAt">
            <div class="label">Available at</div>
            <div class="statement classes">
                <xsl:sequence select="$content.by.class"/>
            </div>
        </div>
        
    </xsl:function>
    
    <xd:doc>
        <xd:desc>
            <xd:p>Gets the ancestors of an attribtue class</xd:p>
        </xd:desc>
        <xd:param name="object"></xd:param>
        <xd:return></xd:return>
    </xd:doc>
    <xsl:function name="tools:getAncestorsOfAttributeClass" as="node()*">
        <xsl:param name="object" as="node()"/>
        
        <xsl:variable name="direct.members" select="$elements/self::tei:elementSpec[.//tei:memberOf/@key = $object/@ident]" as="node()*"/>
        <xsl:variable name="class.members" select="$att.classes/self::tei:classSpec[.//tei:memberOf/@key = $object/@ident]" as="node()*"/>
        
        <xsl:variable name="contents" as="node()*">
            <xsl:for-each select="$direct.members">
                <xsl:sort select="lower-case(@ident)" data-type="text"/>
                <xsl:variable name="current.elem" select="." as="node()"/>
                <xsl:variable name="ident" select="@ident" as="xs:string"/>
                
                <!--<div class="elementRef" data-module="{$current.elem/@module}">
                    <a class="{tools:getLinkClasses($ident)}" href="#{$ident}"><xsl:value-of select="$ident"/></a>
                    <span class="elementDesc">
                        <xsl:apply-templates select="$elements/self::tei:elementSpec[@ident = $ident]/tei:desc" mode="guidelines"/>
                    </span>
                </div>-->
                <item class="element" ident="{$ident}" module="{$elements/self::tei:elementSpec[@ident = $ident]/@module}">
                    <link><a class="{tools:getLinkClasses($ident)}" href="#{$ident}"><xsl:value-of select="$ident"/></a></link>
                    <desc><xsl:apply-templates select="$elements/self::tei:elementSpec[@ident = $ident]/tei:desc" mode="guidelines"/></desc>
                </item>
            </xsl:for-each>
            
            <!--<xsl:if test="$object/@ident = 'att.augmentDots'">
                <xsl:message select="'In here – ' || string-join($class.members/@ident,', ')"/>
                <xsl:for-each select="$class.members">
                    <xsl:variable name="member.class" select="." as="node()"/>
                    <xsl:sequence select="tools:getAncestorsOfAttributeClass($member.class)"/>
                </xsl:for-each>
            </xsl:if>-->
            
            <xsl:for-each select="$class.members">
                <xsl:variable name="member.class" select="." as="node()"/>
                <xsl:sequence select="tools:getAncestorsOfAttributeClass($member.class)"/>
            </xsl:for-each>
        </xsl:variable>
        
        <xsl:sequence select="tools:getClassBox($object/@ident,'',$contents,'')"/>
        
    </xsl:function>
    
    <xd:doc>
        <xd:desc>
            <xd:p>Gets the users of a data type</xd:p>
        </xd:desc>
        <xd:param name="object">the data type</xd:param>
        <xd:return>the resulting div</xd:return>
    </xd:doc>
    <xsl:function name="tools:getDatatypeUsersFacet" as="node()">
        
        <xsl:param name="object" as="node()"/>
        
        <xsl:variable name="referencing.data.types" select="$data.types/self::tei:macroSpec[.//tei:macroRef[@key = $object/@ident] or .//rng:ref[@name = $object/@ident]]" as="node()*"/>
        <xsl:variable name="referencing.att.classes" select="$att.classes/self::tei:classSpec[.//rng:ref[@name = $object/@ident]]" as="node()*"/>
        <xsl:variable name="referencing.elements" select="$elements/self::tei:elementSpec[.//rng:ref[@name = $object/@ident]]" as="node()*"/>
        
        <xsl:variable name="data.type.links" as="node()*">
            <xsl:for-each select="$referencing.data.types">
                <xsl:variable name="ref" select="." as="node()"/>
                <xsl:variable name="desc" select="normalize-space(string-join(tei:desc//text(),' '))" as="xs:string?"/>
                
                <item class="datatype" ident="{$ref/@ident}" module="{$ref/@module}">
                    <link><a class="{tools:getLinkClasses($ref/@ident)}" href="#{$ref/@ident}"><xsl:value-of select="$ref/@ident"/></a></link>
                    <desc><xsl:apply-templates select="tei:desc" mode="guidelines"/></desc>
                </item>
                <!--
                <span class="ident datatype" data-ident="{$ref/@ident}" data-module="{$ref/@module}" title="{$desc}">
                    <a class="{tools:getLinkClasses($ref/@ident)}" href="#{$ref/@ident}"><xsl:value-of select="$ref/@ident"/></a>
                </span>-->
            </xsl:for-each>
        </xsl:variable>
        <xsl:variable name="att.class.links" as="node()*">
            <xsl:for-each select="$referencing.att.classes">
                <xsl:variable name="current.class" select="." as="node()"/>
                <xsl:variable name="class.desc" select="normalize-space(string-join(tei:desc//text(),' '))" as="xs:string?"/>
                <xsl:variable name="attributes" select="$current.class//tei:attDef[.//rng:ref[@name = $object/@ident]]" as="node()+"/>
                <xsl:for-each select="$attributes">
                    <xsl:variable name="current.attribute" select="." as="node()"/>
                    <xsl:variable name="attribute.desc" select="normalize-space(string-join(tei:desc//text(),' '))" as="xs:string?"/>
                    <item class="attclass" ident="{$current.class/@ident}" module="{$current.class/@module}">
                        <link><a class="{tools:getLinkClasses($current.class/@ident)}" href="#{$current.class/@ident}"><xsl:value-of select="$current.class/@ident"/></a>/<span title="{$attribute.desc}">@<xsl:value-of select="$current.attribute/@ident"/></span></link>
                        <desc><xsl:apply-templates select="tei:desc" mode="guidelines"/></desc>
                    </item>
                    <!--<span class="ident attclass" data-ident="{$current.class/@ident}" data-module="{$current.class/@module}">
                        <a class="{tools:getLinkClasses($current.class/@ident)}" title="{$class.desc}" href="#{$current.class/@ident}"><xsl:value-of select="$current.class/@ident"/></a>/<span title="{$attribute.desc}">@<xsl:value-of select="$current.attribute/@ident"/></span>
                    </span>-->
                </xsl:for-each>
            </xsl:for-each>
        </xsl:variable>
        <xsl:variable name="element.links" as="node()*">
            <xsl:for-each select="$referencing.elements">
                <xsl:variable name="current.element" select="." as="node()"/>
                
                <xsl:variable name="desc" select="normalize-space(string-join(tei:desc//text(),' '))" as="xs:string?"/>
                
                <item class="element" ident="{$current.element/@ident}" module="{$current.element/@module}">
                    <link><a class="{tools:getLinkClasses($current.element/@ident)}" href="#{$current.element/@ident}"><xsl:value-of select="$current.element/@ident"/></a></link>
                    <desc><xsl:apply-templates select="tei:desc" mode="guidelines"/></desc>

                    <xsl:variable name="attributes" select="$current.element//tei:attDef[.//rng:ref[@name = $object/@ident]]" as="node()+"/>
                    
                    <xsl:for-each select="$attributes">
                        <xsl:variable name="current.attribute" select="." as="node()"/>
                        <item class="attribute" ident="{$current.attribute/@ident}" module="{$current.element/@module}">
                            <link><xsl:value-of select="$current.attribute/@ident"/></link>
                            <desc><xsl:apply-templates select="$current.attribute/tei:desc" mode="guidelines"/></desc>                    
                        </item>
                    </xsl:for-each>

                </item>
                
                <!--<span class="ident element" data-ident="{$current.element/@ident}" data-module="{$current.element/@module}" title="{$desc}">
                    <a class="{tools:getLinkClasses($current.element/@ident)}" href="#{$current.element/@ident}"><xsl:value-of select="$current.element/@ident"/></a>
                </span>-->
            </xsl:for-each>
        </xsl:variable>
        
        <div class="facet usedBy" id="usedBy">
            <div class="label">Used by</div>
            <div class="statement classes">
                <xsl:choose>
                    <xsl:when test="count($data.type.links) = 0 and count($att.class.links) = 0 and count($element.links) = 0">
                        <span class="emptyStatement">(<em><xsl:value-of select="$object/@ident"/> is not used on any attribute</em>)</span>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:if test="count($element.links) gt 0">
                            <xsl:sequence select="tools:getClassBox('Elements','These local attributes use ' || $object/@ident,$element.links,'dtBox')"/>
                        </xsl:if>
                        <xsl:if test="count($att.class.links) gt 0">
                            <xsl:sequence select="tools:getClassBox('Attribute Classes','These class-based attributes use ' || $object/@ident,$att.class.links,'dtBox')"/>
                        </xsl:if>
                        <xsl:if test="count($data.type.links) gt 0">
                            <xsl:sequence select="tools:getClassBox('Data Types','These other Data Types reference ' || $object/@ident,$data.type.links,'dtBox')"/>
                        </xsl:if>
                    </xsl:otherwise>
                </xsl:choose>
            </div>
        </div>
    </xsl:function>
    
    <xd:doc>
        <xd:desc>
            <xd:p>Retrieves the tolerated values of an attribute</xd:p>
        </xd:desc>
        <xd:param name="object"></xd:param>
        <xd:return></xd:return>
    </xd:doc>
    <xsl:function name="tools:getToleratedValuesFacet" as="node()?">
        <xsl:param name="object" as="node()"/>
        
        <xsl:variable name="values" select="$object//tei:valList/tei:valItem" as="node()*"/>
        
        <xsl:if test="count($values) gt 0">
            <xsl:variable name="valTolerance" select="if($object//tei:valList/@type = 'semi') then('Suggested') else('Allowed')" as="xs:string?"/>
            
            <div class="facet toleratedValues" id="toleratedValues">
                <div class="label"><xsl:value-of select="$valTolerance || ' Values'"/></div>
                <div class="statement list">
                    <xsl:for-each select="$values">
                        <div class="dataValueBox" id="{@ident}">
                            <span class="dataValue ident">
                                <xsl:value-of select="@ident"/>
                            </span>
                            <span class="dataValue desc">
                                <xsl:apply-templates select="tei:desc" mode="guidelines"/>
                            </span>
                        </div>
                    </xsl:for-each>
                </div>
            </div>
        </xsl:if>
    </xsl:function>
    
    <xd:doc>
        <xd:desc>
            <xd:p>Creates a facet for displaying attributes</xd:p>
        </xd:desc>
        <xd:param name="object">The object for which the facet is needed</xd:param>
        <xd:return>The resulting div</xd:return>
    </xd:doc>
    <xsl:function name="tools:getAttributesFacet" as="node()">
        <xsl:param name="object" as="node()"/>
        
        <xsl:variable name="attributes.by.class" as="node()*">
            <xsl:sequence select="tools:handleAttributes($object)"/>
        </xsl:variable>
        <!--<xsl:variable name="attributes.compact" as="node()*">
            <xsl:for-each select="$attributes.by.class//descendant-or-self::div[@class = 'attributeDef def']">
                <xsl:sort select="./span[@class='ident attribute']/text()" data-type="text"/>
                <xsl:if test="position() gt 1">
                    <xsl:value-of select="', '"/>
                </xsl:if>
                <xsl:sequence select="./span[@class='ident attribute']"/>
            </xsl:for-each>
        </xsl:variable>
        <xsl:variable name="attributes.full" as="node()*">
            <xsl:for-each select="$attributes.by.class//descendant-or-self::div[@class = 'attributeDef def']">
                <xsl:sort select="./span[@class='ident attribute']/text()" data-type="text"/>
                <xsl:sequence select="."/>
            </xsl:for-each>
        </xsl:variable>
        <xsl:variable name="attributes.by.module" as="node()*">
            <xsl:for-each select="distinct-values($attributes.by.class//descendant-or-self::div[@class = 'attributeDef def']/@data-module)">
                <xsl:sort select="." data-type="text"/>
                <xsl:variable name="current.module" select="." as="xs:string"/>
                <xsl:variable name="desc" select="normalize-space(string-join($mei.source//tei:moduleSpec[@ident = $current.module]/tei:desc/text(),' '))" as="xs:string"/>
                <xsl:variable name="content" as="node()*">
                    <xsl:for-each select="$attributes.by.class//descendant-or-self::div[@class = 'attributeDef def'][@data-module = $current.module]">
                        <xsl:sort select="./span[@class='ident attribute']/text()" data-type="text"/>
                        <xsl:sequence select="."/>
                    </xsl:for-each>
                </xsl:variable>
                
                <xsl:sequence select="tools:getClassBox($current.module,$desc,$content,'')"/>
                
            </xsl:for-each>
        </xsl:variable>-->
        
        <!--<xsl:variable name="contents" as="node()+">
            <tab id="compact" label="compact"><xsl:sequence select="$attributes.compact"/></tab>
            <tab id="full" label="full definition"><xsl:sequence select="$attributes.full"/></tab>
            <tab id="class" label="by class"><xsl:sequence select="$attributes.by.class"/></tab>
            <tab id="module" label="by module"><xsl:sequence select="$attributes.by.module"/></tab>
        </xsl:variable>-->
        
        <!--<xsl:sequence select="tools:getTabbedFacet('attributes','Attributes',$contents)"/>-->
        
        <div class="facet attributes">
            <div class="label">Attributes</div>
            <div class="statement classes">
                <xsl:sequence select="$attributes.by.class"/>
            </div>
        </div>
        
    </xsl:function>
    
    <xd:doc>
        <xd:desc>
            <xd:p>Resolves Attributes</xd:p>
        </xd:desc>
        <xd:param name="current.element">The object to retrieve attributes from, could be either an element or an att class</xd:param>
        <xd:return></xd:return>
    </xd:doc>
    <xsl:function name="tools:handleAttributes" as="node()*">
        <xsl:param name="current.element" as="node()"/>
        
        <xsl:if test="$current.element//tei:attDef">
            <xsl:variable name="content" as="node()*">
                <xsl:for-each select="$current.element//tei:attDef">
                    <xsl:variable name="current.att" select="." as="node()"/>
                    <xsl:sequence select="tools:resolveAttDef($current.att,$current.element/@module)"/>
                </xsl:for-each>
            </xsl:variable>
            <xsl:sequence select="tools:getClassBox('direct children','',$content,'direct')"/>
        </xsl:if>
        
        <xsl:sequence select="for $attClass in $current.element//tei:memberOf[starts-with(@key,'att.')]/@key return tools:resolveAttClass($attClass, $current.element/@ident)"/>
        
    </xsl:function>
    
    <xd:doc>
        <xd:desc>
            <xd:p>Resolves an attribute class</xd:p>
        </xd:desc>
        <xd:param name="class.name">The name of the att class</xd:param>
        <xd:param name="parent"></xd:param>
        <xd:return></xd:return>
    </xd:doc>
    <xsl:function name="tools:resolveAttClass" as="node()*">
        <xsl:param name="class.name" as="xs:string"/>
        <xsl:param name="parent" as="xs:string"/>
        <xsl:variable name="att.class" select="$att.classes[@ident = $class.name]" as="node()"/>
        
        <xsl:variable name="desc" select="'(' || $att.class/@module || ') ' || normalize-space(string-join($att.class/tei:desc/text(),' '))" as="xs:string"/>
        <xsl:variable name="content" as="node()*">
            <xsl:for-each select="$att.class//tei:attDef">
                <xsl:variable name="current.att" select="." as="node()"/>
                <xsl:sequence select="tools:resolveAttDef($current.att,$att.class/@module)"/>
            </xsl:for-each>
            <xsl:sequence select="for $inherited.class in $att.class//tei:memberOf[starts-with(@key,'att.')]/@key return tools:resolveAttClass($inherited.class,$class.name)"/>
        </xsl:variable>
        
        <xsl:sequence select="tools:getClassBox($class.name,$desc,$content,'')"/>
        
    </xsl:function>
    
    <xd:doc>
        <xd:desc>
            <xd:p>Resolves the definition of an attribute</xd:p>
        </xd:desc>
        <xd:param name="current.att">The current attribute</xd:param>
        <xd:param name="module"></xd:param>
        <xd:return></xd:return>
    </xd:doc>
    <xsl:function name="tools:resolveAttDef" as="node()">
        <xsl:param name="current.att" as="node()"/>
        <xsl:param name="module" as="xs:string"/>
        <xsl:variable name="usage" select="if($current.att/@usage = 'opt') then('optional') else if($current.att/@usage = 'req') then('required') else if($current.att/@usage = 'rec') then('recommended') else($current.att/@usage)" as="xs:string?"/>
        <xsl:variable name="desc" as="node()*">
            <xsl:apply-templates select="$current.att/tei:desc/node()" mode="guidelines"/>
        </xsl:variable>
        <item class="attribute" ident="{$current.att/@ident}" module="{$module}">
            <link><xsl:value-of select="$current.att/@ident"/></link>
            <desc>
                <span class="ident attribute" title="{normalize-space(string-join($desc/descendant-or-self::text(),' '))}"><xsl:value-of select="$current.att/@ident"/></span>
                <xsl:if test="$usage">
                    <span class="attributeUsage">(<xsl:value-of select="$usage"/>)</span>
                </xsl:if>
                <span class="attributeDesc desc"><xsl:sequence select="$desc"/></span>
                <span class="attributeValues">
                    <xsl:choose>
                        <xsl:when test="$current.att/tei:valList">
                            <xsl:variable name="valTolerance" select="if($current.att/tei:valList/@type = 'semi') then('Suggested') else('Allowed')" as="xs:string?"/>
                            <xsl:value-of select="' ' || $valTolerance || ' values are:'"/>
                            <xsl:for-each select="$current.att/tei:valList/tei:valItem">
                                <xsl:if test="position() gt 1">, </xsl:if> "<span style="font-weight: 500;"><xsl:value-of select="@ident"/></span>" <xsl:if test="tei:desc"> <i>(<xsl:value-of select="tei:desc/text()"/>)</i></xsl:if>
                            </xsl:for-each>
                            <xsl:if test="$current.att/tei:valList/@type = 'semi' and $current.att/tei:dataType/rng:data[@type = 'NMTOKEN']">
                                and custom <i>NMToken</i>
                            </xsl:if>
                        </xsl:when>
                        <xsl:when test="$current.att/tei:datatype[rng:ref]">
                            <xsl:variable name="dt" select="$current.att/tei:datatype" as="node()"/>
                            <xsl:choose>
                                <xsl:when test="$dt/@maxOccurs = '1'">
                                    Value conforms to <a class="{tools:getLinkClasses($dt/rng:ref/@name)}" href="#{$dt/rng:ref/@name}"><xsl:value-of select="$dt/rng:ref/@name"/></a>.
                                </xsl:when>
                                <xsl:when test="$dt/@maxOccurs = '2'">
                                    One or two values from <a class="{tools:getLinkClasses($dt/rng:ref/@name)}" href="#{$dt/rng:ref/@name}"><xsl:value-of select="$dt/rng:ref/@name"/></a>, separated by a space.
                                </xsl:when>
                                <xsl:when test="$dt/@maxOccurs = 'unbounded'">
                                    One or more values from <a class="{tools:getLinkClasses($dt/rng:ref/@name)}" href="#{$dt/rng:ref/@name}"><xsl:value-of select="$dt/rng:ref/@name"/></a>, separated by spaces.
                                </xsl:when>
                                <xsl:when test="not($dt/@maxOccurs) and not($dt/@minOccurs)">
                                    Value conforms to <a class="{tools:getLinkClasses($dt/rng:ref/@name)}" href="#{$dt/rng:ref/@name}"><xsl:value-of select="$dt/rng:ref/@name"/></a>.
                                </xsl:when>
                                <xsl:otherwise>
                                    <xsl:message select="'ERROR: Unable to resolve the following datatype on attribute ' || $current.att/@ident"/>
                                    <xsl:message terminate="yes" select="$dt"/>
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:when>
                        <xsl:when test="$current.att/tei:datatype[rng:choice[every $child in child::* satisfies local-name($child) eq 'ref']]">
                            <xsl:variable name="refs" as="node()+">
                                <xsl:for-each select="$current.att/tei:datatype//rng:ref">
                                    <xsl:variable name="separator" as="xs:string">
                                        <xsl:choose>
                                            <xsl:when test="count($current.att/tei:datatype//rng:ref) eq 2 and position() = 1">
                                                <xsl:value-of select="' or '"/>
                                            </xsl:when>
                                            <xsl:when test="position() lt last() -1">
                                                <xsl:value-of select="', '"/>
                                            </xsl:when>
                                            <xsl:when test="position() eq last() -1">
                                                <xsl:value-of select="', or '"/>
                                            </xsl:when>
                                            <xsl:otherwise>
                                                <xsl:value-of select="''"/>
                                            </xsl:otherwise>
                                        </xsl:choose>
                                    </xsl:variable>
                                    <a class="{tools:getLinkClasses(@name)}" href="#{@name}"><xsl:value-of select="@name"/></a><xsl:value-of select="$separator"/>
                                </xsl:for-each>
                            </xsl:variable>
                            Value conforms to either <xsl:sequence select="$refs"/>.
                        </xsl:when>
                        <xsl:when test="$current.att/tei:datatype[rng:data]">
                            <xsl:variable name="dt" select="$current.att/tei:datatype" as="node()"/>
                            <xsl:choose>
                                <xsl:when test="$dt/@maxOccurs = '1'">
                                    Value of datatype <span style="font-weight: 500;"><xsl:sequence select="tools:resolveData($dt//rng:data[1])"/></span>.
                                </xsl:when>
                                <xsl:when test="$dt/@maxOccurs = '2'">
                                    One or two values of datatype <span style="font-weight: 500;"><xsl:sequence select="tools:resolveData($dt//rng:data[1])"/></span>, separated by a space.
                                </xsl:when>
                                <xsl:when test="$dt/@maxOccurs = 'unbounded'">
                                    One or more values of datatype <span style="font-weight: 500;"><xsl:sequence select="tools:resolveData($dt//rng:data[1])"/></span>, separated by spaces.
                                </xsl:when>
                                <xsl:when test="count($dt/child::rng:ref) = 1 and $dt/child::rng:ref/@type = 'string'">
                                    Value is plain text.
                                </xsl:when>
                                <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'string'">
                                    Value is plain text.
                                </xsl:when>
                                <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'ID'">
                                    Value is a valid <a target="_blank" href="https://www.w3.org/TR/xml-id/">xml:id</a>.
                                </xsl:when>
                                <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'decimal'">
                                    Value is a decimal number.
                                </xsl:when>
                                <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'integer'">
                                    Value is an integer.
                                </xsl:when>
                                <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'positiveInteger'">
                                    Value is a positive integer.
                                </xsl:when>
                                <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'nonNegativeInteger'">
                                    Value is a positive integer, including 0.
                                </xsl:when>
                                <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'language'">
                                    Value is a <a target="_blank" href="https://www.w3.org/TR/xmlschema11-2/#language">language</a>.
                                </xsl:when>
                                <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'token'">
                                    Value is a <a target="_blank" href="https://www.w3.org/TR/xmlschema11-2/#token">token</a>.
                                </xsl:when>
                                <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'NMTOKEN'">
                                    Value is a <a target="_blank" href="https://www.w3.org/TR/xmlschema11-2/#NMTOKEN">NMTOKEN</a>.
                                </xsl:when>
                                <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'duration'">
                                    Value is an <a target="_blank" href="https://www.w3.org/TR/xmlschema11-2/#duration">ISO duration</a>.
                                </xsl:when>
                                <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'token' and $dt/child::rng:data/child::rng:param[@name='pattern']">
                                    Value conforms to the pattern "<span style="font-weight: 500;"><xsl:value-of select="$dt//rng:param[@name='pattern']/text()"/></span>".
                                </xsl:when>
                                <xsl:otherwise>
                                    <xsl:message select="'ERROR: Unable to resolve the following datatype on attribute ' || $current.att/@ident"/>
                                    <xsl:message terminate="yes" select="$dt"/>
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:when>
                        <xsl:when test="$current.att/tei:datatype[rng:list]">
                            <xsl:variable name="dt" select="$current.att/tei:datatype" as="node()"/>
                            <xsl:choose>
                                <xsl:when test="$dt/rng:list/rng:oneOrMore/rng:data[@type='token']/rng:param[@name='pattern']">
                                    One or more values conforming to the pattern "<span style="font-weight: 500;"><xsl:value-of select="$dt//rng:param[@name='pattern']/text()"/></span>".
                                </xsl:when>
                                <xsl:when test="count($dt/rng:list/rng:oneOrMore/rng:data) = 2">
                                    One or more values, each consisting of a sequence of <span style="font-weight: 500;"><xsl:sequence select="tools:resolveData($dt//rng:data[1])"/></span> and <span style="font-weight: 500;"><xsl:sequence select="tools:resolveData($dt//rng:data[2])"/></span> sub-values.
                                </xsl:when>
                                <xsl:when test="count($dt/rng:list/rng:oneOrMore/rng:data) = 1">
                                    One or more of <span style="font-weight: 500;"><xsl:sequence select="tools:resolveData($dt//rng:data[1])"/></span>.
                                </xsl:when>
                                <xsl:when test="$dt/rng:list/rng:oneOrMore/rng:data[following-sibling::rng:ref]">
                                    One or more values, each consisting of a sequence of a <span style="font-weight: 500;"><xsl:sequence select="tools:resolveData($dt//rng:data)"/></span> part, followed by a <a class="{tools:getLinkClasses($dt/rng:ref/@name)}" href="#{$dt/rng:ref/@name}"><xsl:value-of select="$dt//rng:ref/@name"/></a>.
                                </xsl:when>
                                <xsl:otherwise>
                                    <xsl:message select="'ERROR: Unable to resolve the following datatype on attribute ' || $current.att/@ident"/>
                                    <xsl:message terminate="yes" select="$dt"/>
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:when>
                        <xsl:when test="$current.att/tei:datatype[rng:choice]">
                            <xsl:variable name="dt" select="$current.att/tei:datatype" as="node()"/>
                            <xsl:choose>
                                <xsl:when test="$dt/rng:choice[count(child::rng:data) = 2]">
                                    Value must either conform to <span style="font-weight: 500;"><xsl:sequence select="tools:resolveData($dt//rng:data[1])"/></span> or <span style="font-weight: 500;"><xsl:sequence select="tools:resolveData($dt//rng:data[2])"/></span>.                            
                                </xsl:when>
                                <xsl:when test="$dt/rng:choice[count(child::*) = 1]">
                                    Value must conform to <span style="font-weight: 500;"><xsl:sequence select="tools:resolveData($dt//rng:data[1])"/></span>.                            
                                </xsl:when>
                                <xsl:when test="$dt/rng:choice[count(child::*) = 2 and rng:ref[@name = 'data.BOOLEAN'] and rng:value]">
                                    Value must conform to <span style="font-weight: 500;">data.BOOLEAN</span> or <span style="font-weight: 500;"><xsl:value-of select="$dt/rng:choice/rng:value/text()"/></span>.                            
                                </xsl:when>
                                <xsl:otherwise>
                                    <xsl:message select="'ERROR: Unable to resolve the following datatype on attribute ' || $current.att/@ident"/>
                                    <xsl:message terminate="yes" select="$dt"/>
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:when>
                        <xsl:when test="$current.att/tei:datatype[rng:text]">
                            <xsl:variable name="dt" select="$current.att/tei:datatype" as="node()"/>
                            <xsl:choose>
                                <xsl:when test="count($dt/child::*) = 1 and $dt/rng:text and $dt/@maxOccurs = '1'">
                                    Value is plain text.
                                </xsl:when>
                                <xsl:when test="count($dt/child::*) = 1 and $dt/rng:text and not($dt/@maxOccurs)">
                                    Value is plain text.
                                </xsl:when>
                                <xsl:otherwise>
                                    <xsl:message select="'ERROR: Unable to resolve the following datatype on attribute ' || $current.att/@ident"/>
                                    <xsl:message terminate="no" select="$dt"/>
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:message select="'WARNING: Not sure how to resolve the values of attDef ' || $current.att/@ident"/>
                        </xsl:otherwise>
                    </xsl:choose>
                </span>
            </desc>
        </item>
        
        <!--
        <div class="attributeDef def" data-module="{$module}">
            <span class="ident attribute" title="{normalize-space(string-join($desc/descendant-or-self::text(),' '))}"><xsl:value-of select="$current.att/@ident"/></span>
            <xsl:if test="$usage">
                <span class="attributeUsage">(<xsl:value-of select="$usage"/>)</span>
            </xsl:if>
            <span class="attributeDesc desc"><xsl:sequence select="$desc"/></span>
            <span class="attributeValues">
                <xsl:choose>
                    <xsl:when test="$current.att/tei:valList">
                        Allowed values are:
                        <xsl:for-each select="$current.att/tei:valList/tei:valItem">
                            <xsl:if test="position() gt 1">, </xsl:if> "<span style="font-weight: 500;"><xsl:value-of select="@ident"/></span>" <xsl:if test="tei:desc"> <i>(<xsl:value-of select="tei:desc/text()"/>)</i></xsl:if>
                        </xsl:for-each>
                        <xsl:if test="$current.att/tei:valList/@type = 'semi' and $current.att/tei:dataType/rng:data[@type = 'NMTOKEN']">
                            and custom <i>NMToken</i>
                        </xsl:if>
                    </xsl:when>
                    <xsl:when test="$current.att/tei:datatype[rng:ref]">
                        <xsl:variable name="dt" select="$current.att/tei:datatype" as="node()"/>
                        <xsl:choose>
                            <xsl:when test="$dt/@maxOccurs = '1'">
                                Value conforms to <a class="{tools:getLinkClasses($dt/rng:ref/@name)}" href="#{$dt/rng:ref/@name}"><xsl:value-of select="$dt/rng:ref/@name"/></a>.
                            </xsl:when>
                            <xsl:when test="$dt/@maxOccurs = '2'">
                                One or two values from <a class="{tools:getLinkClasses($dt/rng:ref/@name)}" href="#{$dt/rng:ref/@name}"><xsl:value-of select="$dt/rng:ref/@name"/></a>, separated by a space.
                            </xsl:when>
                            <xsl:when test="$dt/@maxOccurs = 'unbounded'">
                                One or more values from <a class="{tools:getLinkClasses($dt/rng:ref/@name)}" href="#{$dt/rng:ref/@name}"><xsl:value-of select="$dt/rng:ref/@name"/></a>, separated by spaces.
                            </xsl:when>
                            <xsl:when test="not($dt/@maxOccurs) and not($dt/@minOccurs)">
                                Value conforms to <a class="{tools:getLinkClasses($dt/rng:ref/@name)}" href="#{$dt/rng:ref/@name}"><xsl:value-of select="$dt/rng:ref/@name"/></a>.
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:message select="'ERROR: Unable to resolve the following datatype on attribute ' || $current.att/@ident"/>
                                <xsl:message terminate="yes" select="$dt"/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:when test="$current.att/tei:datatype[rng:data]">
                        <xsl:variable name="dt" select="$current.att/tei:datatype" as="node()"/>
                        <xsl:choose>
                            <xsl:when test="$dt/@maxOccurs = '1'">
                                Value of datatype <span style="font-weight: 500;"><xsl:sequence select="tools:resolveData($dt//rng:data[1])"/></span>.
                            </xsl:when>
                            <xsl:when test="$dt/@maxOccurs = '2'">
                                One or two values of datatype <span style="font-weight: 500;"><xsl:sequence select="tools:resolveData($dt//rng:data[1])"/></span>, separated by a space.
                            </xsl:when>
                            <xsl:when test="$dt/@maxOccurs = 'unbounded'">
                                One or more values of datatype <span style="font-weight: 500;"><xsl:sequence select="tools:resolveData($dt//rng:data[1])"/></span>, separated by spaces.
                            </xsl:when>
                            <xsl:when test="count($dt/child::rng:ref) = 1 and $dt/child::rng:ref/@type = 'string'">
                                Value is plain text.
                            </xsl:when>
                            <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'string'">
                                Value is plain text.
                            </xsl:when>
                            <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'ID'">
                                Value is a valid <a target="_blank" href="https://www.w3.org/TR/xml-id/">xml:id</a>.
                            </xsl:when>
                            <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'decimal'">
                                Value is a decimal number.
                            </xsl:when>
                            <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'integer'">
                                Value is an integer.
                            </xsl:when>
                            <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'positiveInteger'">
                                Value is a positive integer.
                            </xsl:when>
                            <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'nonNegativeInteger'">
                                Value is a positive integer, including 0.
                            </xsl:when>
                            <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'language'">
                                Value is a <a target="_blank" href="https://www.w3.org/TR/xmlschema11-2/#language">language</a>.
                            </xsl:when>
                            <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'token'">
                                Value is a <a target="_blank" href="https://www.w3.org/TR/xmlschema11-2/#token">token</a>.
                            </xsl:when>
                            <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'NMTOKEN'">
                                Value is a <a target="_blank" href="https://www.w3.org/TR/xmlschema11-2/#NMTOKEN">NMTOKEN</a>.
                            </xsl:when>
                            <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'duration'">
                                Value is an <a target="_blank" href="https://www.w3.org/TR/xmlschema11-2/#duration">ISO duration</a>.
                            </xsl:when>
                            <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'token' and $dt/child::rng:data/child::rng:param[@name='pattern']">
                                Value conforms to the pattern "<span style="font-weight: 500;"><xsl:value-of select="$dt//rng:param[@name='pattern']/text()"/></span>".
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:message select="'ERROR: Unable to resolve the following datatype on attribute ' || $current.att/@ident"/>
                                <xsl:message terminate="yes" select="$dt"/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:when test="$current.att/tei:datatype[rng:list]">
                        <xsl:variable name="dt" select="$current.att/tei:datatype" as="node()"/>
                        <xsl:choose>
                            <xsl:when test="$dt/rng:list/rng:oneOrMore/rng:data[@type='token']/rng:param[@name='pattern']">
                                One or more values conforming to the pattern "<span style="font-weight: 500;"><xsl:value-of select="$dt//rng:param[@name='pattern']/text()"/></span>".
                            </xsl:when>
                            <xsl:when test="count($dt/rng:list/rng:oneOrMore/rng:data) = 2">
                                One or more values, each consisting of a sequence of <span style="font-weight: 500;"><xsl:sequence select="tools:resolveData($dt//rng:data[1])"/></span> and <span style="font-weight: 500;"><xsl:sequence select="tools:resolveData($dt//rng:data[2])"/></span> sub-values.
                            </xsl:when>
                            <xsl:when test="count($dt/rng:list/rng:oneOrMore/rng:data) = 1">
                                One or more of <span style="font-weight: 500;"><xsl:sequence select="tools:resolveData($dt//rng:data[1])"/></span>.
                            </xsl:when>
                            <xsl:when test="$dt/rng:list/rng:oneOrMore/rng:data[following-sibling::rng:ref]">
                                One or more values, each consisting of a sequence of a <span style="font-weight: 500;"><xsl:sequence select="tools:resolveData($dt//rng:data)"/></span> part, followed by a <a class="{tools:getLinkClasses($dt/rng:ref/@name)}" href="#{$dt/rng:ref/@name}"><xsl:value-of select="$dt//rng:ref/@name"/></a>.
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:message select="'ERROR: Unable to resolve the following datatype on attribute ' || $current.att/@ident"/>
                                <xsl:message terminate="yes" select="$dt"/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:when test="$current.att/tei:datatype[rng:choice]">
                        <xsl:variable name="dt" select="$current.att/tei:datatype" as="node()"/>
                        <xsl:choose>
                            <xsl:when test="$dt/rng:choice[count(child::rng:data) = 2]">
                                Value must either conform to <span style="font-weight: 500;"><xsl:sequence select="tools:resolveData($dt//rng:data[1])"/></span> or <span style="font-weight: 500;"><xsl:sequence select="tools:resolveData($dt//rng:data[2])"/></span>.                            
                            </xsl:when>
                            <xsl:when test="$dt/rng:choice[count(child::*) = 1]">
                                Value must conform to <span style="font-weight: 500;"><xsl:sequence select="tools:resolveData($dt//rng:data[1])"/></span>.                            
                            </xsl:when>
                            <xsl:when test="$dt/rng:choice[count(child::*) = 2 and rng:ref[@name = 'data.BOOLEAN'] and rng:value]">
                                Value must conform to <span style="font-weight: 500;">data.BOOLEAN</span> or <span style="font-weight: 500;"><xsl:value-of select="$dt/rng:choice/rng:value/text()"/></span>.                            
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:message select="'ERROR: Unable to resolve the following datatype on attribute ' || $current.att/@ident"/>
                                <xsl:message terminate="yes" select="$dt"/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:when test="$current.att/tei:datatype[rng:text]">
                        <xsl:variable name="dt" select="$current.att/tei:datatype" as="node()"/>
                        <xsl:choose>
                            <xsl:when test="count($dt/child::*) = 1 and $dt/rng:text and $dt/@maxOccurs = '1'">
                                Value is plain text.
                            </xsl:when>
                            <xsl:when test="count($dt/child::*) = 1 and $dt/rng:text and not($dt/@maxOccurs)">
                                Value is plain text.
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:message select="'ERROR: Unable to resolve the following datatype on attribute ' || $current.att/@ident"/>
                                <xsl:message terminate="no" select="$dt"/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:message select="'WARNING: Not sure how to resolve the values of attDef ' || $current.att/@ident"/>
                    </xsl:otherwise>
                </xsl:choose>
            </span>
        </div>-->
        
    </xsl:function>
    
    <xd:doc>
        <xd:desc>
            <xd:p>Translates a data type into a descriptive string</xd:p>
        </xd:desc>
        <xd:param name="data"></xd:param>
        <xd:return></xd:return>
    </xd:doc>
    <xsl:function name="tools:resolveData" as="node()+">
        <xsl:param name="data" as="node()"/>
        
        <xsl:choose>
            <xsl:when test="not($data/child::*)">
                <xsl:value-of select="$data/@type"/>
            </xsl:when>
            <xsl:when test="$data/@type = ('string','token') and $data/rng:param[@name = 'pattern']">
                a string matching the following regular expression: "<xsl:value-of select="$data/rng:param/text()"/>"
            </xsl:when>
            <xsl:when test="$data/@type = 'decimal' and $data/rng:param[@name = 'minInclusive'] and $data/rng:param[@name = 'maxInclusive']">
                a decimal number between <xsl:value-of select="$data/rng:param[@name = 'minInclusive']/text()"/> and <xsl:value-of select="$data/rng:param[@name = 'maxInclusive']/text()"/>
            </xsl:when>
            <xsl:when test="$data/@type = 'positiveInteger' and $data/rng:param[@name = 'minInclusive'] and $data/rng:param[@name = 'maxInclusive']">
                a positive integer between <xsl:value-of select="$data/rng:param[@name = 'minInclusive']/text()"/> and <xsl:value-of select="$data/rng:param[@name = 'maxInclusive']/text()"/>
            </xsl:when>
            <xsl:when test="$data/@type = 'positiveInteger' and $data/rng:param[@name = 'maxInclusive']">
                a positive integer no larger than <xsl:value-of select="$data/rng:param/text()"/>
            </xsl:when>
            <xsl:when test="$data/@type = 'positiveInteger' and $data/rng:param[@name = 'minInclusive']">
                a positive integer no smaller than <xsl:value-of select="$data/rng:param/text()" />
            </xsl:when>
            <xsl:when test="$data/@type = 'nonNegativeInteger' and $data/rng:param[@name = 'maxInclusive']">
                a non-negative integer no larger than <xsl:value-of select="$data/rng:param/text()"/>
            </xsl:when>
            <xsl:when test="$data/@type = 'decimal' and $data/rng:param[@name = 'minInclusive']">
                a decimal number no smaller than <xsl:value-of select="$data/rng:param/text()"/>
            </xsl:when>
            <xsl:when test="$data/@type = 'decimal' and $data/rng:param[@name = 'minExclusive']">
                a decimal number larger than <xsl:value-of select="$data/rng:param/text()"/>
            </xsl:when>
            <xsl:when test="$data/@type = 'positiveInteger' and $data/rng:param[@name = 'pattern']">
                one of the following integers: <xsl:value-of select="string-join(tokenize($data/rng:param/text(),'|'),', ')"/>
            </xsl:when>
            <xsl:when test="$data/@type = 'decimal' and $data/rng:param[@name = 'pattern']">
                a decimal number matching the pattern "<xsl:value-of select="$data/rng:param/text()"/>"
            </xsl:when>
            <xsl:otherwise>
                <xsl:message select="'ERROR: Cannot resolve the following datatype:'"/>
                <xsl:message terminate="yes" select="$data"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>
    
    
    <xd:doc>
        <xd:desc>
            <xd:p>Returns a facet with information about memberships</xd:p>
        </xd:desc>
        <xd:param name="object"></xd:param>
        <xd:return></xd:return>
    </xd:doc>
    <xsl:function name="tools:getMemberOfFacet" as="node()">
        <xsl:param name="object" as="node()"/>
        <div class="facet memberships">
            <div class="label">Member of</div>
            <div class="statement memberships">
                <xsl:variable name="memberships" select="$object//tei:memberOf[starts-with(@key,'model.')]" as="node()*"/>
                <xsl:for-each select="$memberships">
                    <xsl:variable name="key" select="@key" as="xs:string"/>
                    <xsl:variable name="model.desc" select="normalize-space(string-join($model.classes/self::tei:classSpec[@ident = $key]/tei:desc/text(),' '))" as="xs:string"/>
                    <div class="memberOf">
                        <a class="{tools:getLinkClasses($key)}" href="#{$key}"><xsl:value-of select="@key"/></a>
                        <span class="groupDesc"><xsl:value-of select="$model.desc"/></span>
                    </div>
                </xsl:for-each>
                <xsl:if test="count($memberships) = 0">
                    <div class="memberOf">
                        <span class="groupDesc">(<xsl:value-of select="$object/@ident"/> isn't member of any model class)</span>
                    </div>
                </xsl:if>
            </div>
        </div>
    </xsl:function>
    
    <xd:doc>
        <xd:desc>
            <xd:p>Returns a facet with information where an element may occur</xd:p>
        </xd:desc>
        <xd:param name="object">the object for which parents are sought</xd:param>
        <xd:return>the resulting div</xd:return>
    </xd:doc>
    <xsl:function name="tools:getContainedByFacet" as="node()">
        <xsl:param name="object" as="node()"/>
        
        <!--<xsl:variable name="direct.parents" select="$elements/self::tei:elementSpec[.//tei:content//rng:ref[@name = $object/@ident]]" as="node()*"/>-->
        <!--<xsl:variable name="class.parents" select="tools:getParents($model.classes/self::tei:classSpec[@ident = $object//tei:memberOf[starts-with(@key,'model.')]/@key])" as="node()*"/>
        <xsl:variable name="macro.parents" select="tools:getParents($macro.groups/self::tei:macroSpec[.//tei:content//rng:ref[@name = $object/@ident]])" as="node()*"/>
        <xsl:variable name="parents" select="$direct.parents | $class.parents | $macro.parents" as="node()*"/>
        
        <xsl:variable name="parents.compact" as="node()*">
            <xsl:for-each select="$parents/self::tei:elementSpec">
                <xsl:sort select="@ident" data-type="text"/>
                <xsl:variable name="current.elem" select="@ident" as="xs:string"/>
                <xsl:variable name="desc" select="normalize-space(string-join(tei:desc//text(),' '))" as="xs:string"/>
                <xsl:if test="position() gt 1">
                    <xsl:value-of select="', '"/>
                </xsl:if>
                <span class="ident element" title="{$desc}">
                    <a class="{tools:getLinkClasses($current.elem)}" href="#{$current.elem}"><xsl:value-of select="$current.elem"/></a>
                </span>
            </xsl:for-each>
            
        </xsl:variable>-->
        <xsl:variable name="parents.by.class" select="tools:getParentsByModel($object)" as="node()*"/>
        <!--<xsl:variable name="parents.by.module" as="node()*">
            <xsl:for-each select="distinct-values($parents/self::tei:elementSpec/@module)">
                <xsl:sort select="." data-type="text"/>
                <xsl:variable name="current.module" select="." as="xs:string"/>
                <xsl:variable name="relevant.element.names" select="distinct-values($parents/self::tei:elementSpec[@module = $current.module]/@ident)" as="xs:string*"/>
                
                <xsl:variable name="ident" select="$current.module" as="xs:string"/>
                <xsl:variable name="desc" select="normalize-space(string-join($mei.source//tei:moduleSpec[@ident = $current.module]/tei:desc/text(),' '))" as="xs:string"/>
                <xsl:variable name="content" as="node()*">
                    <xsl:for-each select="$relevant.element.names">
                        <xsl:sort select="." data-type="text"/>
                        <xsl:variable name="current.elem" select="." as="xs:string"/>
                        
                        <div class="elementRef">
                            <a class="{tools:getLinkClasses($current.elem)}" href="#{$current.elem}"><xsl:value-of select="$current.elem"/></a>
                            <span class="elementDesc">
                                <xsl:apply-templates select="$elements/self::tei:elementSpec[@ident = $current.elem]/tei:desc" mode="parse.odd"/>
                            </span>
                        </div>
                    </xsl:for-each>
                </xsl:variable>
                
                <xsl:sequence select="tools:getClassBox($ident,$desc,$content,'')"/>
                
            </xsl:for-each>
        </xsl:variable>-->
        
        <!--<xsl:variable name="contents" as="node()+">
            <tab id="compact" label="compact"><xsl:sequence select="$parents.compact"/></tab>
            <tab id="class" label="by class"><xsl:sequence select="$parents.by.class"/></tab>
            <tab id="module" label="by module"><xsl:sequence select="$parents.by.module"/></tab>
        </xsl:variable>
        
        <xsl:sequence select="tools:getTabbedFacet('containedBy','Contained by',$contents)"/>-->
        
        <div class="facet containedBy">
            <div class="label">Contained By</div>
            <div class="statement classes">
                <xsl:sequence select="$parents.by.class"/>
            </div>
        </div>
        
    </xsl:function>
    
    
    <xd:doc>
        <xd:desc>
            <xd:p>Retrieves the parents through model classes</xd:p>
        </xd:desc>
        <xd:param name="object"></xd:param>
        <xd:return></xd:return>
    </xd:doc>
    <xsl:function name="tools:getParentsByModel" as="node()*">
        <xsl:param name="object" as="node()"/>
        <xsl:variable name="is.element" select="local-name($object) = 'elementSpec'" as="xs:boolean"/>
        <xsl:variable name="is.macroGroup" select="local-name($object) = 'macroSpec' and $object/@type = 'pe'" as="xs:boolean"/>
        
        <xsl:variable name="direct.parents" select="$elements/self::tei:elementSpec[.//tei:content//rng:ref[@name = $object/@ident]]" as="node()*"/>
        
        <xsl:variable name="ident" select="if($is.element) then('elements having ' || $object/@ident || ' as direct children') else($object/@ident)" as="xs:string"/>
        <xsl:variable name="desc" select="if($is.element) then('') else('(' || $object/@module || ') ' || normalize-space(string-join($object/tei:desc/text(),' ')))" as="xs:string"/>
        <xsl:variable name="content" as="node()*">
            <xsl:for-each select="$direct.parents">
                <xsl:sort select="@ident" data-type="text"/>
                <xsl:variable name="current.elem" select="@ident" as="xs:string"/>
                <xsl:variable name="desc" select="normalize-space(string-join(./tei:desc//text(),' '))" as="xs:string"/>
                <!--<div class="elementDef def">
                    <span class="ident element" title="{$desc}">
                        <a class="{tools:getLinkClasses($current.elem)}" href="#{$current.elem}"><xsl:value-of select="$current.elem"/></a>
                    </span>
                    <span class="elementDesc desc">
                        <xsl:apply-templates select="./tei:desc/node()" mode="guidelines"/>
                    </span>
                </div>-->
                <item class="element" ident="{$current.elem}" module="{$elements/self::tei:elementSpec[@ident = $current.elem]/@module}">
                    <link><a class="{tools:getLinkClasses($current.elem)}" href="#{$current.elem}"><xsl:value-of select="$current.elem"/></a></link>
                    <desc><xsl:apply-templates select="tei:desc/node()" mode="guidelines"/></desc>
                </item>
            </xsl:for-each>
            <xsl:if test="not($is.element) and not($is.macroGroup)">
                <xsl:sequence select="tools:processAncestorModels($object)"/>
            </xsl:if>            
        </xsl:variable>
        
        <xsl:if test="not($is.element) or count($direct.parents) gt 0">
            <xsl:sequence select="tools:getClassBox($ident,$desc,$content,'')"/>
        </xsl:if>
        
        <xsl:if test="$is.element">
            <xsl:sequence select="tools:processAncestorModels($object)"/>  
        </xsl:if>      
        
    </xsl:function>

    <xd:doc>
        <xd:desc>
            <xd:p>Processes ancestor models for a given object</xd:p>
        </xd:desc>
        <xd:param name="object"></xd:param>
        <xd:return></xd:return>
    </xd:doc>
    <xsl:function name="tools:processAncestorModels" as="node()*">
        <xsl:param name="object" as="node()"/>
        <xsl:variable name="class.parents" select="$model.classes/self::tei:classSpec[@ident = $object//tei:memberOf[starts-with(@key,'model.')]/@key]" as="node()*"/>
        <xsl:variable name="macro.parents" select="$macro.groups/self::tei:macroSpec[.//tei:content//rng:ref[@name = $object/@ident]]" as="node()*"/>
        <xsl:variable name="ancestor.models" as="node()*">
            <xsl:sequence select="$class.parents"/>
            <xsl:sequence select="$macro.parents"/>
        </xsl:variable>
        <xsl:for-each select="$ancestor.models">
            <xsl:sequence select="tools:getParentsByModel(.)"/>    
        </xsl:for-each>
    </xsl:function>
    
    <xd:doc>
        <xd:desc>
            <xd:p>Gets parents. Not sure this is really needed at this point</xd:p>
        </xd:desc>
        <xd:param name="model.classes"></xd:param>
        <xd:return></xd:return>
    </xd:doc>
    <xsl:function name="tools:getParents" as="node()*">
        <xsl:param name="model.classes" as="node()*"/>
        
        <xsl:for-each select="$model.classes">
            <xsl:variable name="current.model" select="." as="node()"/>
            <xsl:variable name="relevant.elements" select="$mei.source//tei:elementSpec[(:.//tei:memberOf[@key = $current.model/@ident] or :).//tei:content//rng:ref[@name = $current.model/@ident]]" as="node()*"/>
            <!--<xsl:message select="'  INFO: looking for ' || count($relevant.elements) || ' elements in ' || $current.model/@ident"/>-->
            <xsl:sequence select="$relevant.elements"/>
            <xsl:variable name="inheriting.classes" select="$mei.source//tei:classSpec[@type = 'model' and @ident = $current.model//tei:memberOf/@key]" as="node()*"/>
            <xsl:sequence select="tools:getParents($inheriting.classes)"/>
        </xsl:for-each>
    </xsl:function>
    
    <xd:doc>
        <xd:desc>
            <xd:p>Gets children. Not sure this is really needed at this point</xd:p>
        </xd:desc>
        <xd:param name="model.classes"></xd:param>
        <xd:return></xd:return>
    </xd:doc>
    <xsl:function name="tools:getChildren" as="node()*">
        <xsl:param name="className" as="xs:string"/>
        <xsl:sequence select="$elements/self::tei:elementSpec[.//tei:memberOf[@key = $className]]"/>
        
        <xsl:variable name="inheriting.models" select="$model.classes/self::tei:classSpec[.//tei:memberOf/@key = $className]/@ident" as="xs:string*"/>
        <xsl:for-each select="$inheriting.models">
            <xsl:sequence select="tools:getChildren(.)"/>    
        </xsl:for-each>
        
    </xsl:function>
    
    <xd:doc>
        <xd:desc>
            <xd:p>Retrieves a facet with allowed children</xd:p>
        </xd:desc>
        <xd:param name="object"></xd:param>
        <xd:return></xd:return>
    </xd:doc>
    <xsl:function name="tools:getMayContainFacet" as="node()">
        <xsl:param name="object" as="node()"/>
        
        <xsl:variable name="direct.children" select="$elements/self::tei:elementSpec[@ident = $object//tei:content//rng:ref[not(starts-with(@name,'model.'))]/@name]" as="node()*"/>
        <xsl:variable name="class.children" as="node()*">
            <xsl:for-each select="$object//tei:content//rng:ref[starts-with(@name,'model.')]">
                <xsl:variable name="modelClass.name" select="@name" as="xs:string"/>
                <xsl:sequence select="tools:getChildren($modelClass.name)"/>
            </xsl:for-each>
        </xsl:variable>
        <xsl:variable name="macro.children" as="node()*">
            <xsl:for-each select="$object//tei:content//rng:ref[starts-with(@name,'macro.')]">
                <xsl:variable name="macroSpec.name" select="@name" as="xs:string"/>
                <xsl:variable name="macroSpec" select="$macro.groups/self::tei:macroSpec[@ident = $macroSpec.name]" as="node()?"/>
                <xsl:if test="not($macroSpec)">
                    <xsl:message select="$macroSpec.name || ' missing at ' || $object/@ident" terminate="yes"/>
                </xsl:if>
                <xsl:sequence select="$elements/self::tei:elementSpec[@ident = $macroSpec//tei:content//rng:ref/@name]"/>
                <xsl:for-each select="$macroSpec//tei:content//rng:ref[starts-with(@name,'model.')]">
                    <xsl:sequence select="tools:getChildren(@name)"/>    
                </xsl:for-each>
            </xsl:for-each>
        </xsl:variable>
        <xsl:variable name="children" select="$direct.children | $class.children | $macro.children" as="node()*"/>
        <xsl:variable name="allows.anyXML" select="exists($object/tei:content/rng:element[rng:anyName and rng:zeroOrMore/rng:attribute/rng:anyName and rng:zeroOrMore//rng:text and rng:zeroOrMore//rng:ref[@name = $object/@ident]])" as="xs:boolean"/>
        <xsl:variable name="allows.text" as="xs:boolean">
            <xsl:variable name="regular.text" select="xs:boolean(not($allows.anyXML) and exists($object/tei:content//rng:text))" as="xs:boolean"/>
            <xsl:variable name="macro.text" select="some $macroSpec in (for $name in $object//tei:content//rng:ref[starts-with(@name,'macro.')]/@name return ($macro.groups/self::tei:macroSpec[@ident = $name])) satisfies exists($macroSpec//tei:content//rng:text)" as="xs:boolean"/>
            <xsl:value-of select="$regular.text or $macro.text"/>
        </xsl:variable>
        
        <xsl:choose>
            <xsl:when test="count($children) gt 0 or $allows.text">
                <!--<xsl:variable name="children.compact" as="node()*">
                    <xsl:if test="$allows.text">
                        <span class="ident textualContent" title="textual content">textual content</span>
                    </xsl:if>
                    <xsl:for-each select="$children/self::tei:elementSpec">
                        <xsl:sort select="@ident" data-type="text"/>
                        <xsl:variable name="current.elem" select="@ident" as="xs:string"/>
                        <xsl:variable name="desc" select="normalize-space(string-join(tei:desc//text(),' '))" as="xs:string"/>
                        <xsl:if test="position() gt 1 or $allows.text">
                            <xsl:value-of select="', '"/>
                        </xsl:if>
                        <span class="ident element" title="{$desc}">
                            <a class="{tools:getLinkClasses($current.elem)}" href="#{$current.elem}"><xsl:value-of select="$current.elem"/></a>
                        </span>
                    </xsl:for-each>
                </xsl:variable>-->
                <xsl:variable name="children.by.class" as="node()*">
                    <xsl:if test="$allows.text">
                        <div class="textualContent" title="textual content">
                            textual content
                        </div>
                    </xsl:if>
                    <xsl:sequence select="tools:getChildrenByModel($object)"/>
                </xsl:variable>
                <!--<xsl:variable name="children.by.module" as="node()*">
                    
                    <xsl:if test="$allows.text">
                        <div class="textualContent" title="textual content">
                            textual content
                        </div>
                    </xsl:if>
                    
                    <xsl:for-each select="distinct-values($children/self::tei:elementSpec/@module)">
                        <xsl:sort select="." data-type="text"/>
                        <xsl:variable name="current.module" select="." as="xs:string"/>
                        <xsl:variable name="relevant.element.names" select="distinct-values($children/self::tei:elementSpec[@module = $current.module]/@ident)" as="xs:string*"/>
                        
                        <xsl:variable name="ident" select="$current.module" as="xs:string"/>
                        <xsl:variable name="desc" select="normalize-space(string-join($mei.source//tei:moduleSpec[@ident = $current.module]/tei:desc/text(),' '))" as="xs:string"/>
                        <xsl:variable name="content" as="node()*">
                            
                            <xsl:for-each select="$relevant.element.names">
                                <xsl:sort select="." data-type="text"/>
                                <xsl:variable name="current.elem" select="." as="xs:string"/>
                                
                                <div class="elementRef" title="{$current.elem}">
                                    <a class="{tools:getLinkClasses($current.elem)}" href="#{$current.elem}"><xsl:value-of select="$current.elem"/></a>
                                    <span class="elementDesc">
                                        <xsl:apply-templates select="$elements/self::tei:elementSpec[@ident = $current.elem]/tei:desc" mode="parse.odd"/>
                                    </span>
                                </div>
                            </xsl:for-each>
                        </xsl:variable>
                        
                        <xsl:sequence select="tools:getClassBox($ident,$desc,$content,'')"/>
                        
                    </xsl:for-each>
                </xsl:variable>-->
                
                <!--<xsl:variable name="contents" as="node()+">
                    <tab id="compact" label="compact"><xsl:sequence select="$children.compact"/></tab>
                    <tab id="class" label="by class"><xsl:sequence select="$children.by.class"/></tab>
                    <tab id="module" label="by module"><xsl:sequence select="$children.by.module"/></tab>
                </xsl:variable>
                
                <xsl:sequence select="tools:getTabbedFacet('mayContain','May Contain',$contents)"/>    -->    
                
                <div class="facet mayContain">
                    <div class="label">May Contain</div>
                    <div class="statement classes">
                        <xsl:sequence select="$children.by.class"/>
                    </div>
                </div>
            </xsl:when>
            <xsl:when test="$allows.anyXML">
                
                <div class="facet mayContain" id="mayContain">
                    <div class="label">May Contain</div>
                    <div class="statement text">
                        any XML element, with any attribute <span class="emptyStatement">(<em><xsl:value-of select="$object/@ident"/> is self-nested</em>)</span>
                    </div>
                </div>
            </xsl:when>
            <xsl:otherwise>
                <xsl:variable name="prefix" select="if(local-name($object) = 'elementSpec') then('&lt;') else('')" as="xs:string"/>
                <xsl:variable name="postfix" select="if(local-name($object) = 'elementSpec') then('&gt;') else('')" as="xs:string"/>
                
                <div class="facet mayContain" id="mayContain">
                    <div class="label">May Contain</div>
                    <div class="statement text">
                        – <span class="emptyStatement">(<em><xsl:value-of select="$prefix || $object/@ident || $postfix"/> may not have child elements</em>)</span>
                    </div>
                </div>
            </xsl:otherwise>
        </xsl:choose>
        
    </xsl:function>
    
    <xd:doc>
        <xd:desc>
            <xd:p>Gets child elements by model</xd:p>
        </xd:desc>
        <xd:param name="object"></xd:param>
        <xd:return></xd:return>
    </xd:doc>
    <xsl:function name="tools:getChildrenByModel" as="node()*">
        <xsl:param name="object" as="node()"/>
        
        <xsl:variable name="is.element" select="local-name($object) = 'elementSpec'" as="xs:boolean"/>
        <xsl:variable name="is.model" select="local-name($object) = 'classSpec' and $object/@type = 'model'" as="xs:boolean"/>
        <xsl:variable name="is.macro" select="local-name($object) = 'macroSpec' and $object/@type = 'pe'" as="xs:boolean"/>
        <xsl:variable name="ident" select="if($is.element) then('direct children') else($object/@ident)" as="xs:string"/>
        <xsl:variable name="desc" select="if($is.element) then('') else('(' || $object/@module || ') ' || normalize-space(string-join($object/tei:desc/text(),' ')))" as="xs:string"/>
        
        <xsl:variable name="allows.text" select="exists($object//tei:content//rng:text)" as="xs:boolean"/>
        
        <xsl:variable name="relevant.elements" as="node()*">
            <xsl:choose>
                <xsl:when test="$is.element">
                    <xsl:sequence select="$elements/self::tei:elementSpec[@ident = $object//tei:content//rng:ref[not(starts-with(@name,'model.')) and not(starts-with(@name, 'macro.'))]/@name]"/>
                </xsl:when>
                <xsl:when test="$is.model">
                    <xsl:sequence select="$elements/self::tei:elementSpec[.//tei:memberOf[@key = $object/@ident]]"/>
                </xsl:when>
                <xsl:when test="$is.macro">
                    <xsl:sequence select="$elements/self::tei:elementSpec[@ident = $object//tei:content//rng:ref[not(starts-with(@name,'model.'))]/@name]"/>
                </xsl:when>
            </xsl:choose>
        </xsl:variable>
        <xsl:if test="not($is.element) or count($relevant.elements) gt 0">
            <xsl:variable name="content" as="node()*">
                <xsl:if test="$allows.text">
                    <!--<div class="textualContent" title="textual content">
                        textual content
                    </div>-->                    
                    <text/>
                </xsl:if>
                <xsl:for-each select="$relevant.elements">
                    <xsl:sort select="@ident" data-type="text"/>
                    <xsl:variable name="current.elem" select="@ident" as="xs:string"/>
                    <xsl:variable name="desc" select="normalize-space(string-join(./tei:desc//text(),' '))" as="xs:string"/>
                    <item class="element" ident="{$current.elem}" module="{$elements/self::tei:elementSpec[@ident = $current.elem]/@module}">
                        <link><a class="{tools:getLinkClasses($current.elem)}" href="#{$current.elem}"><xsl:value-of select="$current.elem"/></a></link>
                        <desc><xsl:apply-templates select="tei:desc" mode="guidelines"/></desc>
                    </item>
                    <!--<div class="elementDef def">
                        <span class="ident element" title="{$desc}">
                            <a class="{tools:getLinkClasses($current.elem)}" href="#{$current.elem}"><xsl:value-of select="$current.elem"/></a>
                        </span>
                        <span class="elementDesc desc">
                            <xsl:apply-templates select="./tei:desc/node()" mode="guidelines"/>
                        </span>
                    </div>-->
                </xsl:for-each>
                <xsl:if test="not($is.element)">
                    <xsl:variable name="inheriting.models" as="node()*">
                        <xsl:sequence select="$model.classes/self::tei:classSpec[.//tei:memberOf/@key = $object/@ident]"/>
                        <xsl:sequence select="$macro.groups/self::tei:macroSpec[.//tei:memberOf/@key = $object/@ident]"/>
                        <xsl:sequence select="$model.classes/self::tei:classSpec[@ident = $object/tei:content//rng:ref/@name]"/>
                        <xsl:sequence select="$macro.groups/self::tei:macroSpec[@ident = $object/tei:content//rng:ref/@name and not(@ident = $object/@ident)]"/>
                    </xsl:variable>
                    <xsl:for-each select="$inheriting.models">
                        <xsl:sequence select="tools:getChildrenByModel(.)"/>    
                    </xsl:for-each>
                </xsl:if>
            </xsl:variable>
            <xsl:sequence select="tools:getClassBox($ident,$desc,$content,(if($is.element) then('direct') else('')))"/>
        </xsl:if>
        
        <xsl:if test="$is.element">
            <xsl:variable name="inheriting.models" as="node()*">
                <xsl:sequence select="$model.classes/self::tei:classSpec[@ident = $object//tei:content//rng:ref[starts-with(@name,'model.')]/@name]"/>
                <xsl:sequence select="$macro.groups/self::tei:macroSpec[@ident = $object/tei:content//rng:ref/@name]"/>
            </xsl:variable>
            <xsl:for-each select="$inheriting.models">
                <xsl:sequence select="tools:getChildrenByModel(.)"/>    
            </xsl:for-each>
        </xsl:if>
    </xsl:function>
    
    <xd:doc>
        <xd:desc>
            <xd:p>Retrieves the remarks for an object, if any</xd:p>
        </xd:desc>
        <xd:param name="object"></xd:param>
        <xd:return></xd:return>
    </xd:doc>
    <xsl:function name="tools:getRemarksFacet" as="node()?">
        <xsl:param name="object" as="node()"/>
        
        <xsl:if test="$object/tei:remarks">
            <div class="facet remarks">
                <div class="label">Remarks</div>
                <div class="statement remarks">
                    <xsl:apply-templates select="$object/tei:remarks/node()" mode="guidelines"/>
                </div>
            </div>
        </xsl:if>
        
    </xsl:function>
    
    
    <xd:doc>
        <xd:desc>
            <xd:p>Returns the schematron facet for an object, if applicable</xd:p>
        </xd:desc>
        <xd:param name="object"></xd:param>
        <xd:return></xd:return>
    </xd:doc>
    <xsl:function name="tools:getSchematronFacet" as="node()?">
        <xsl:param name="object" as="node()"/>
        
        <xsl:if test="$object//tei:constraintSpec">
            
            <xsl:variable name="compact.constraints" as="node()*">
                <xsl:for-each select="$object//tei:constraintSpec">
                    <div class="constraint">
                        <xsl:for-each select=".//sch:assert">
                            <!-- TODO: Do we loose text from pointers here? -->
                            <div class="schematronText"><xsl:value-of select="normalize-space(string-join(.//text(),' '))"/></div>
                        </xsl:for-each>
                    </div>
                </xsl:for-each>
            </xsl:variable>
            <!--<xsl:variable name="schematron.constraints" as="node()*">
                <xsl:for-each select="$object//tei:constraintSpec">
                    <div class="constraint">
                        <div class="code" xml:space="preserve" data-lang="Schematron"><code><xsl:apply-templates select=".//sch:rule" mode="preserveSpace"/></code></div>
                    </div>
                </xsl:for-each>
            </xsl:variable>-->
            
            <!--<xsl:variable name="contents" as="node()+">
                <tab id="text" label="text"><xsl:sequence select="$compact.constraints"/></tab>
                <tab id="schematron" label="schematron"><xsl:sequence select="$schematron.constraints"/></tab>
            </xsl:variable>-->
            
            <div class="facet constraints">
                <div class="label">Constraints</div>
                <div class="statement constraints">
                    <p><xsl:sequence select="$compact.constraints"/></p>
                </div>
            </div>
            
            
        </xsl:if>
    </xsl:function>
    
    
    <xd:doc>
        <xd:desc>
            <xd:p>Retrieves the specs for an object</xd:p>
        </xd:desc>
        <xd:param name="object"></xd:param>
        <xd:return></xd:return>
    </xd:doc>
    <xsl:function name="tools:getDeclarationFacet" as="node()">
        <xsl:param name="object" as="node()"/>
        
        <div class="facet declaration">
            <div class="label">Declaration</div>
            <div class="statement declaration">
                <xsl:variable name="codeBlock">
                    <!--<xsl:apply-templates select="$object/(tei:classes | tei:content)" mode="preserveSpace">-->
                    <xsl:apply-templates select="$object" mode="preserveSpace">
                        <xsl:with-param name="getODD" tunnel="yes" select="true()"/>
                    </xsl:apply-templates>
                </xsl:variable>
                <div class="code" xml:space="preserve" data-lang="ODD"><code><xsl:sequence select="$codeBlock"/></code></div>
            </div>
        </div>
    </xsl:function>
    
    
    <xd:doc>
        <xd:desc>
            <xd:p>Deals with element references inside specs</xd:p>
        </xd:desc>
    </xd:doc>
    <xsl:template match="tei:gi" mode="parse.odd">
        <xsl:variable name="text" select="string(text())" as="xs:string"/>
        <xsl:choose>
            <xsl:when test="$text = $elements/@ident">
                <a class="{tools:getLinkClasses($text)}" href="#{$text}"><xsl:value-of select="$text"/></a>
            </xsl:when>
            <xsl:otherwise>
                <xsl:message select="'WARNING: Unable to retrieve definition of element ' || $text || '. No link created. Please check spelling…'"/>
                <xsl:next-match/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    
    <xd:doc>
        <xd:desc>
            <xd:p>Deals with attributes mentioned in specs</xd:p>
        </xd:desc>
    </xd:doc>
    <xsl:template match="tei:att" mode="parse.odd">
        <span class="att"><xsl:apply-templates select="node()" mode="#current"/></span>
    </xsl:template>
    
    <xd:doc>
        <xd:desc>
            <xd:p>Deals with descriptions in specs</xd:p>
        </xd:desc>
    </xd:doc>
    <xsl:template match="tei:desc" mode="parse.odd guidelines">
        <span class="desc"><xsl:apply-templates select="node()" mode="#current"/></span>
    </xsl:template>
    
    
</xsl:stylesheet>
